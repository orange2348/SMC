//
// The contents of this file are subject to the Mozilla Public
// License Version 1.1 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy
// of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an
// "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//
// The Original Code is State Machine Compiler (SMC).
//
// The Initial Developer of the Original Code is Charles W. Rapp.
// Portions created by Charles W. Rapp are
// Copyright (C) 2005, 2008 - 2009, 2019. Charles W. Rapp.
// All Rights Reserved.
//
// Contributor(s):
//   Eitan Suez contributed examples/Ant.
//   (Name withheld) contributed the C# code generation and
//   examples/C#.
//   Francois Perrad contributed the Python code generation and
//   examples/Python.
//   Chris Liscio contributed the Objective-C code generation
//   and examples/ObjC.
//
// RCS ID
// $Id: SmcCGenerator.java,v 1.20 2015/02/16 21:43:09 cwrapp Exp $
//
// CHANGE LOG
// (See the bottom of this file.)
//

package net.sf.smc.generator;

import java.io.StringWriter;
import java.util.Iterator;
import java.util.List;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcFSM;
import net.sf.smc.model.SmcGuard;
import net.sf.smc.model.SmcMap;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.SmcState;
import net.sf.smc.model.SmcTransition;
import net.sf.smc.model.SmcVisitor;
import net.sf.smc.model.TargetLanguage;

/**
 * Visits the abstract syntax tree emitting C code to an output
 * stream.
 * @see SmcElement
 * @see SmcCodeGenerator
 * @see SmcVisitor
 * @see SmcOptions
 *
 * @author Francois Perrad
 */

public final class SmcCGenerator
    extends SmcCodeGenerator
{
//---------------------------------------------------------------
// Member data
//

    //-----------------------------------------------------------
    // Locals.
    //

    // This FSM belongs to this "class".
    private String mContext;

//---------------------------------------------------------------
// Member methods
//

    //-----------------------------------------------------------
    // Constructors.
    //

    /**
     * Creates a C code generator for the given options.
     * @param options The target code generator options.
     */
    public SmcCGenerator(final SmcOptions options)
    {
        super (options, TargetLanguage.C.suffix());
    } // end of SmcCGenerator(SmcOptions)

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // SmcVisitor Abstract Method Impelementation.
    //

    /**
     * Emits the following C code for the FSM:
     * <pre>
     *   <code>
 %{ %} raw target code - if any

 #include &lt;%include header file&gt;
     * #include "<i>context</i>.h"
     *   </code>
     * </pre>
     * If the -headerd option is used, then this is generated:
     * <pre>
     *   <code>
     * #include "<i>header dir</i>/<i>context</i>.h")
     *   </code>
     * </pre>
     * @param fsm Emit code for this finite state machine.
     */
    @Override
    public void visit(final SmcFSM fsm)
    {
        String targetfileCaps;
        String packageName = fsm.getPackage();
        String rawSource = fsm.getSource();
        String context = fsm.getContext();
        String fsmClassName = fsm.getFsmClassName();
        String mapName;
        String startStateName = fsm.getStartState();
        List<SmcTransition> transList;
        List<SmcParameter> params;
        String cState;
        int index;

        mTarget.println("/*");
        mTarget.println(" * ex: set ro:");
        mTarget.println(" * DO NOT EDIT.");
        mTarget.println(" * generated by smc (http://smc.sourceforge.net/)");
        mTarget.print(" * from file : ");
        mTarget.print(mSrcfileBase);
        mTarget.println(".sm");
        mTarget.println(" */");
        mTarget.println();

        // If a package has been specified,
        if (packageName != null && packageName.length() > 0)
        {
            context = packageName + "_" + context;
            fsmClassName = packageName + "_" + fsmClassName;
            startStateName = packageName + "_" + startStateName;
        }

        // Dump out the raw target code, if any.
        if (rawSource != null && rawSource.length() > 0)
        {
            mTarget.println(rawSource);
            mTarget.println();
        }

        // Generate #includes.
        for (String include: fsm.getIncludes())
        {
            mTarget.print("#include ");
            mTarget.println(include);
        }

        // Include the context file last.
        // Is the header file included in a different directory
        // than the target file?
        mTarget.print("#include \"");
        if (!mSrcDirectory.equals(mHeaderDirectory))
        {
            // They are in different directories. Prepend the
            // path from the target file directory to the header
            // file directory.
            mTarget.print(
                findPath(mSrcDirectory, mHeaderDirectory));
        }
        // Else they are in the same directory.
        else
        {
            mTarget.print(mSrcDirectory);
        }
        mTarget.print(mTargetfileBase);
        mTarget.format(".%s\"%n", mHeaderSuffix);

        // Print out the default definitions for all the
        // transitions. First, get the transitions list.
        transList = fsm.getTransitions();

        mTarget.println();
        mTarget.println("#define getOwner(fsm) (fsm)->_owner");

        mTarget.println();
        if (fsm.hasEntryActions())
        {
            mTarget.println("#define ENTRY_STATE(state) \\");
            mTarget.println("    if ((state)->Entry != NULL) { \\");
            mTarget.println("        (state)->Entry(fsm); \\");
            mTarget.println("    }");
        }
        mTarget.println();
        if (fsm.hasExitActions())
        {
            mTarget.println("#define EXIT_STATE(state) \\");
            mTarget.println("    if ((state)->Exit != NULL) { \\");
            mTarget.println("        (state)->Exit(fsm); \\");
            mTarget.println("    }");
        }

        // Output the default transition definitions.
        for (SmcTransition trans: transList)
        {
            if (!trans.getName().equals("Default"))
            {
                mTarget.println();
                mTarget.print("static void ");
                mTarget.print(context);
                mTarget.print("State_");
                mTarget.print(trans.getName());
                mTarget.print("(struct ");
                mTarget.print(fsmClassName);
                mTarget.print(" *const fsm");

                params = trans.getParameters();
                for (SmcParameter param: params)
                {
                    mTarget.print(", ");
                    param.accept(this);
                }

                mTarget.println(")");
                mTarget.println("{");
                mTarget.println(
                    "    getState(fsm)->Default(fsm);");
                mTarget.println("}");
            }
        }

        mTarget.println();
        mTarget.print("static void ");
        mTarget.print(context);
        mTarget.print("State_Default(struct ");
        mTarget.print(fsmClassName);
        mTarget.println(" *const fsm)");
        mTarget.println("{");

        // Print the transition out to the verbose log.
        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            mTarget.println("    if (getDebugFlag(fsm) != 0) {");

            // The TRACE macro.
            mTarget.print("        TRACE(");
            mTarget.print("\"TRANSITION   : %s.%s\\n\", ");
            mTarget.println(
                "getName(getState(fsm)), getTransition(fsm));");

            mTarget.println("    }");
        }
        mTarget.println("    State_Default(fsm);");
        mTarget.println("}");

        // Have each map print out its target code now.
        for (SmcMap map: fsm.getMaps())
        {
            mapName = map.getName();
            if (packageName != null && packageName.length() > 0)
            {
                mapName = packageName + "_" + mapName;
            }
            mTarget.println();

            for (SmcState state: map.getStates())
            {
                for (SmcTransition trans: transList)
                {
                    if (!trans.getName().equals("Default"))
                    {
                        mTarget.print("#define ");
                        mTarget.print(mapName);
                        mTarget.print("_");
                        mTarget.print(state.getInstanceName());
                        mTarget.print("_");
                        mTarget.print(trans.getName());
                        mTarget.print(" ");
                        mTarget.print(context);
                        mTarget.print("State_");
                        mTarget.println(trans.getName());
                    }
                }

                mTarget.print("#define ");
                mTarget.print(mapName);
                mTarget.print("_");
                mTarget.print(state.getInstanceName());
                mTarget.print("_Default ");
                mTarget.print(context);
                mTarget.println("State_Default");
            }

            for (SmcTransition trans: transList)
            {
                if (!trans.getName().equals("Default"))
                {
                    mTarget.print("#define ");
                    mTarget.print(mapName);
                    mTarget.print("_DefaultState_");
                    mTarget.print(trans.getName());
                    mTarget.print(" ");
                    mTarget.print(context);
                    mTarget.print("State_");
                    mTarget.println(trans.getName());
                }
            }

            map.accept(this);
        }

        // Make the file name upper case and replace
        // slashes with underscores.
        targetfileCaps = mTargetfileBase.replace('\\', '_');
        targetfileCaps = targetfileCaps.replace('/', '_');
        targetfileCaps = targetfileCaps.toUpperCase();
        mTarget.println();
        mTarget.print("#ifdef NO_");
        mTarget.print(targetfileCaps);
        mTarget.println("_MACRO");

        // The state name "map::state" must be changed to
        // "map_state".
        if ((index = startStateName.indexOf("::")) >= 0)
        {
            cState =
                    startStateName.substring(0, index) +
                    "_" +
                startStateName.substring(index + 2);
        }
        else
        {
            cState = startStateName;
        }

        // Constructor.
        mTarget.print("void ");
        mTarget.print(fsmClassName);
        mTarget.print("_Init");
        mTarget.print("(struct ");
        mTarget.print(fsmClassName);
        mTarget.print(" *const fsm, struct ");
        mTarget.print(context);
        mTarget.println(" *const owner)");
        mTarget.println("{");
        mTarget.print("    FSM_INIT(fsm, &");
        mTarget.print(cState);
        mTarget.println(");");
        mTarget.println("    fsm->_owner = owner;");
        mTarget.println("}");

        // EnterStartState method.
        if (fsm.hasEntryActions())
        {
            mTarget.println();
            mTarget.print("void ");
            mTarget.print(fsmClassName);
            mTarget.print("_EnterStartState(struct ");
            mTarget.print(fsmClassName);
            mTarget.println(" *const fsm)");
            mTarget.println("{");
            mTarget.println("    ENTRY_STATE(getState(fsm));");
            mTarget.println("}");
        }

        // Generate the context class.
        // Generate a method for every transition in every map
        // *except* the default transition.
        for (SmcTransition trans: transList)
        {
            if (!trans.getName().equals("Default"))
            {
                mTarget.println();
                mTarget.print("void ");
                mTarget.print(fsmClassName);
                mTarget.print("_");
                mTarget.print(trans.getName());
                mTarget.print("(struct ");
                mTarget.print(fsmClassName);
                mTarget.print(" *const fsm");

                params = trans.getParameters();
                for (SmcParameter param: params)
                {
                    mTarget.print(", ");
                    mTarget.print(param.getType());
                    mTarget.print(" ");
                    mTarget.print(param.getName());
                }
                mTarget.println(")");
                mTarget.println("{");

                mTarget.print("    const struct ");
                mTarget.print(context);
                mTarget.println("State* state = getState(fsm);");
                mTarget.println();

                mTarget.println("    assert(state != NULL);");
                mTarget.print("    setTransition(fsm, \"");
                mTarget.print(trans.getName());
                mTarget.println("\");");
                mTarget.print("    state->");
                mTarget.print(trans.getName());
                mTarget.print("(fsm");
                for (SmcParameter param: params)
                {
                    mTarget.print(", ");
                    mTarget.print(param.getName());
                }
                mTarget.println(");");
                mTarget.println("    setTransition(fsm, NULL);");

                mTarget.println("}");
            }
        }
        mTarget.println("#endif");


        mTarget.println();
        mTarget.println("/*");
        mTarget.println(" * Local variables:");
        mTarget.println(" *  buffer-read-only: t");
        mTarget.println(" * End:");
        mTarget.println(" */");

        return;
    } // end of visit(SmcFSM)

    /**
     * Emits C code for the FSM map. Visits the map default
     * state first (if there is one) and then each of the map's
     * states.
     * @param map emit code for this FSM map.
     */
    @Override
    public void visit(final SmcMap map)
    {
        String packageName = map.getFSM().getPackage();
        String context = map.getFSM().getContext();
        String mapName = map.getName();
        String transName;
        String stateName;
        List<SmcAction> actions;

        // If a package has been specified,
        if (packageName != null && packageName.length() > 0)
        {
            context = packageName + "_" + context;
            mapName = packageName + "_" + mapName;
        }

        // Declare the user-defined default transitions first.
        if (map.hasDefaultState())
        {
            SmcState defaultState = map.getDefaultState();

            for (SmcTransition trans:
                     defaultState.getTransitions())
            {
                transName = trans.getName();

                mTarget.println();

                for (SmcState state: map.getStates())
                {
                    stateName = state.getInstanceName();

                    // Firstly, make sure the transition name
                    // is not defined.
                    mTarget.print("#undef ");
                    mTarget.print(mapName);
                    mTarget.print("_");
                    mTarget.print(stateName);
                    mTarget.print("_");
                    mTarget.println(transName);

                    // Secondly, define the transition name
                    // to be a default transition alias.
                    mTarget.print("#define ");
                    mTarget.print(mapName);
                    mTarget.print("_");
                    mTarget.print(stateName);
                    mTarget.print("_");
                    mTarget.print(transName);
                    mTarget.print(" ");
                    mTarget.print(mapName);
                    mTarget.print("_DefaultState_");
                    mTarget.println(transName);
                }

                mTarget.print("#undef ");
                mTarget.print(mapName);
                mTarget.print("_DefaultState_");
                mTarget.println(transName);

                trans.accept(this);
            }
        }

        // Have each state now generate its code.
        for (SmcState state: map.getStates())
        {
            stateName = state.getInstanceName();

            state.accept(this);

            mTarget.println();
            mTarget.print("const struct ");
            mTarget.print(context);
            mTarget.print("State ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(stateName);
            mTarget.println(" = {");
            if (map.getFSM().hasEntryActions())
            {
                mTarget.print("    ");
                actions = state.getEntryActions();
                if (actions != null && !actions.isEmpty())
                {
                    mTarget.print(mapName);
                    mTarget.print("_");
                    mTarget.print(stateName);
                    mTarget.println("_Entry,");
                }
                else
                {
                    mTarget.println("NULL, /* Entry */");
                }
            }
            if (map.getFSM().hasExitActions())
            {
                mTarget.print("    ");
                actions = state.getExitActions();
                if (actions != null && !actions.isEmpty())
                {
                    mTarget.print(mapName);
                    mTarget.print("_");
                    mTarget.print(stateName);
                    mTarget.println("_Exit,");
                }
                else
                {
                    mTarget.println("NULL, /* Exit */");
                }
            }
            for (SmcTransition trans: map.getFSM().getTransitions())
            {
                if (!trans.getName().equals("Default"))
                {
                    mTarget.print("    ");
                    mTarget.print(mapName);
                    mTarget.print("_");
                    mTarget.print(stateName);
                    mTarget.print("_");
                    mTarget.print(trans.getName());
                    mTarget.println(",");
                }
            }
            mTarget.print("    ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(stateName);
            mTarget.println("_Default,");
            mTarget.print("    ");
            mTarget.print(SmcMap.getNextStateId());
            if (mDebugLevel >= DEBUG_LEVEL_0)
            {
                mTarget.print(", \"");
                mTarget.print(mapName);
                mTarget.print("_");
                mTarget.print(stateName);
                mTarget.print("\"");
            }
            mTarget.println("\n};");
        }

        return;
    } // end of visit(SmcMap)

    /**
     * Emits C code for this FSM state. Generates entry and exit
     * action routines first (if any) and then the transition
     * routines.
     * @param state emit C code for this FSM state.
     */
    @Override
    public void visit(final SmcState state)
    {
        SmcMap map = state.getMap();
        String packageName = map.getFSM().getPackage();
        String context = map.getFSM().getContext();
        String fsmClassName = map.getFSM().getFsmClassName();
        String mapName = map.getName();
        String instanceName = state.getInstanceName();
        String indent2;
        List<SmcAction> actions;

        // If a package has been specified,
        if (packageName != null && packageName.length() > 0)
        {
            context = packageName + "_" + context;
            fsmClassName = packageName + "_" + fsmClassName;
            mapName = packageName + "_" + mapName;
        }

        mContext = context;

        // Add the Entry() and Exit() methods if this state
        // defines them.
        actions = state.getEntryActions();
        if (actions != null && !actions.isEmpty())
        {
            mTarget.println();
            mTarget.print("void ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(instanceName);
            mTarget.print("_Entry(struct ");
            mTarget.print(fsmClassName);
            mTarget.println(" *const fsm)");
            mTarget.println("{");

            // Declare the "ctxt" local variable.
            mTarget.print("    struct ");
            mTarget.print(context);
            mTarget.println(" *ctxt = getOwner(fsm);");
            mTarget.println();

            // Generate the actions associated with this code.
            indent2 = mIndent;
            mIndent += "    ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            mIndent = indent2;

            // End the Entry() method.
            mTarget.println("}");
        }

        actions = state.getExitActions();
        if (actions != null && !actions.isEmpty())
        {
            mTarget.println();
            mTarget.print("void ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(instanceName);
            mTarget.print("_Exit(struct ");
            mTarget.print(fsmClassName);
            mTarget.println(" *const fsm)");
            mTarget.println("{");

            // Declare the "ctxt" local variable.
            mTarget.print("    struct ");
            mTarget.print(context);
            mTarget.println(" *ctxt = getOwner(fsm);");
            mTarget.println();

            // Generate the actions associated with this code.
            indent2 = mIndent;
            mIndent += "    ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            mIndent = indent2;

            // End the Entry() method.
            mTarget.println("}");
        }

        // Have the transitions generate their code.
        for (SmcTransition transition: state.getTransitions())
        {
            transition.accept(this);
        }

        return;
    } // end of visit(SmcState)

    /**
     * Emits C code for this FSM transition. Generates the
     * transition subroutine and then each of the guards within
     * that routine.
     * @param transition emit C code for this FSM transition.
     */
    @Override
    public void visit(final SmcTransition transition)
    {
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String packageName = map.getFSM().getPackage();
        String context = map.getFSM().getContext();
        String fsmClassName = map.getFSM().getFsmClassName();
        String mapName = map.getName();
        String stateName = state.getInstanceName();
        String transName = transition.getName();
        SmcGuard nullGuard = null;
        List<SmcGuard> guards = transition.getGuards();
        Iterator<SmcGuard> git = guards.iterator();
        SmcGuard guard;

        // If a package has been specified,
        if (packageName != null && packageName.length() > 0)
        {
            context = packageName + "_" + context;
            fsmClassName = packageName + "_" + fsmClassName;
            mapName = packageName + "_" + mapName;
        }

        if (!stateName.equals("DefaultState"))
        {
            mTarget.println();
            mTarget.print("#undef ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(stateName);
            mTarget.print("_");
            mTarget.println(transName);
        }

        mTarget.print("static void ");
        mTarget.print(mapName);
        mTarget.print("_");
        mTarget.print(stateName);
        mTarget.print("_");
        mTarget.print(transName);
        mTarget.print("(struct ");
        mTarget.print(fsmClassName);
        mTarget.print(" *const fsm");

        // Add user-defined parameters.
        for (SmcParameter parameter: transition.getParameters())
        {
            mTarget.print(", ");
            parameter.accept(this);
        }

        mTarget.println(")");
        mTarget.println("{");

        // All transitions have a "ctxt" local variable.
        // 8/14/2003:
        // Do this only if there are any transition actions or
        // guard conditions which reference it.
        if (transition.hasCtxtReference())
        {
            mTarget.print("    struct ");
            mTarget.print(context);
            mTarget.println(" *ctxt = getOwner(fsm);");
        }

        // ANSI C requires all local variables be declared
        // at the code block's start before any control
        // statements. If this transition appears only once
        // in the state, has at least one action and it is a
        // loopback and debugging is on, then visit(SmcGuard)
        // will generate a local variable declaration after the
        // debug if clause - an ANSI syntax error.
        // So we need to check if this transition meets that
        // condition and generate the local variable declaration
        // here rather than in visit(SmcGuard).
        //
        // Note: when guard count is > 1, then the guard code
        // is placed into an if or else block - and so the
        // end state variable will appear at the start of that
        // block, nullifying the debug if clauses affect.
        mGuardCount = guards.size();
        if (mGuardCount == 1)
        {
            guard = guards.get(0);

            if (guard.hasActions() &&
                isLoopback(guard.getTransType(), guard.getEndState()))
            {
                mTarget.print("    const struct ");
                mTarget.print(context);
                mTarget.println(
                    "State* EndStateName = getState(fsm);");
            }
        }

        mTarget.println();

        // Print the transition to the verbose log.
        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            mTarget.println("    if (getDebugFlag(fsm) != 0) {");
            mTarget.print("        TRACE(\"LEAVING STATE   : ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(stateName);
            mTarget.println(")\\n\");");
            mTarget.println("    }");
        }

        // Loop through the guards and print each one.
        mGuardIndex = 0;
        while (git.hasNext())
        {
            guard = git.next();

            // Output the no condition guard *after* all other
            // guarded transitions.
            if (!guard.hasCondition())
            {
                nullGuard = guard;
            }
            else
            {
                guard.accept(this);
                ++mGuardIndex;
            }
        }

        // Is there an unguarded transition?
        if (nullGuard != null)
        {
            // Does this guard have any actions or is this guard
            // *not* an internal loopback transition?
            if (nullGuard.hasActions() ||
                !(nullGuard.getEndState()).equals(SmcElement.NIL_STATE) ||
                nullGuard.getTransType() == TransType.TRANS_PUSH ||
                nullGuard.getTransType() == TransType.TRANS_POP)
            {
                // Need to output either the action and/or the
                // next state, so output the guard.
                nullGuard.accept(this);
            }

            mTarget.println();
        }
        // If all guards have a condition, then create a final
        // "else" clause which passes control to the default
        // transition.
        else if (mGuardIndex > 0)
        {
            // If there was only one guard, then we need to close
            // off its body.
            if (mGuardCount == 1)
            {
                mTarget.println("    }");
            }

            mTarget.println("    else {");
            mTarget.print("        ");
            if (!stateName.equals("DefaultState"))
            {
                mTarget.print(mapName);
                mTarget.print("_DefaultState_");
            }
            else
            {
                mTarget.print(context);
                mTarget.print("State_");
            }
            mTarget.print(transName);
            mTarget.print("(fsm");

            // Output user-defined parameters.
            for (SmcParameter param: transition.getParameters())
            {
                mTarget.print(", ");
                mTarget.print(param.getName());
            }

            mTarget.println(");");
            mTarget.println("    }");
            mTarget.println();
        }

        mTarget.println("}");

        return;
    } // end of visit(SmcTransition)

    /**
     * Emits C code for this FSM guard. If the guard has a
     * condition, then the condition is placed inside an
     * {@code [else] if} statement. The exit actions, transition
     * actions, setting the next state and entry actions are
     * called from within the condition body. If the condition
     * has no condition but there are other guards, then the
     * guard actions are placed within an {@code else} body.
     * If the guard has no condition and there are no other
     * guards, then the guard action code is emitted within the
     * transition routine block.
     * @param guard emit C code for this transition guard.
     */
    @Override
    public void visit(final SmcGuard guard)
    {
        SmcTransition transition = guard.getTransition();
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String packageName = map.getFSM().getPackage();
        String context = map.getFSM().getContext();
        String fsmClassName = map.getFSM().getFsmClassName();
        String mapName = map.getName();
        String stateName = state.getInstanceName();
        String transName = transition.getName();
        TransType transType = guard.getTransType();
        boolean loopbackFlag;
        String indent2;
        String indent3;
        String indent4;
        String endStateName = guard.getEndState();
        String fqEndStateName = "";
        String pushStateName = guard.getPushState();
        String condition = guard.getCondition();
        List<SmcAction> actions = guard.getActions();

        // If a package has been specified,
        if (packageName != null && packageName.length() > 0)
        {
            context = packageName + "_" + context;
            fsmClassName = packageName + "_" + fsmClassName;
            mapName = packageName + "_" + mapName;
        }

        mContext = context;

        // If this guard's end state is not of the form
        // "map::state", then prepend the map name to the state
        // name.
        // DON'T DO THIS IF THIS IS A POP TRANSITION!
        // The "state" is actually a transition name.
        if (transType != TransType.TRANS_POP &&
            endStateName.length () > 0 &&
            !endStateName.equalsIgnoreCase(SmcElement.NIL_STATE))
        {
            endStateName = scopeStateName(endStateName, map.getName());
            if (packageName != null && packageName.length() > 0)
            {
                endStateName =
                    "&" + packageName + "_" + endStateName;
            }
            else
            {
                endStateName = "&" + endStateName;
            }
        }

        // Qualify the state and push state names as well.
        stateName = "&" + scopeStateName(stateName, mapName);
        pushStateName = scopeStateName(pushStateName, mapName);
        if (packageName != null && packageName.length() > 0)
        {
            pushStateName =
                "&" + packageName + "_" + pushStateName;
        }
        else
        {
            pushStateName = "&" + pushStateName;
        }

        loopbackFlag = isLoopback(transType, endStateName);

        // The guard code generation is a bit tricky. The first
        // question is how many guards are there? If there are
        // more than one, then we will need to generate the
        // proper "if-then-else" code.
        if (mGuardCount > 1)
        {
            indent2 = mIndent + "        ";

            // More than one guard. Is this the first guard?
            if (mGuardIndex == 0 && condition.length() > 0)
            {
                // Yes, this is the first. This means an
                // "if" should be used for this condition.
                mTarget.print(mIndent);
                mTarget.print("    if (");
                mTarget.print(condition);
                mTarget.println(") {");
            }
            else if (condition.length() > 0)
            {
                // No, this is not the first transition but it
                // does have a condition. Use an "else if" for
                // the condition.
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.print("    else if (");
                mTarget.print(condition);
                mTarget.println(") {");
            }
            else
            {
                // This is not the first transition and it has
                // no condition.
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.println("    else {");
            }
        }
        else
        {
            // There is only one guard. Does this guard have a
            // condition.
            if (condition == null || condition.isEmpty())
            {
                // Actually, this is a plain, old, vaniila
                // transition.
                indent2 = mIndent + "    ";
            }
            else
            {
                // Yes, there is a condition.
                mTarget.print(mIndent);
                mTarget.print("    if (");
                mTarget.print(condition);
                mTarget.println(") {");
                indent2 = mIndent + "        ";
            }
        }

        // Now that the necessary conditions are in place, it's
        // time to dump out the transitions actions. First, do
        // the proper handling of the state change. If this
        // transition has no actions, then set the end state
        // immediately. Otherwise, unset the current state so
        // that if an action tries to issue a transition, it will
        // fail.
        if (actions.isEmpty() && !endStateName.isEmpty())
        {
            fqEndStateName = endStateName;
        }
        else if (actions.size() > 0)
        {
            // Save away the current state if this is a loopback
            // transition. Storing current state allows the
            // current to be cleared before any actions are
            // executed. Remember: actions are not allowed to
            // issue transitions and clearing the current state
            // prevents them from doing so.
            if (loopbackFlag)
            {
                fqEndStateName = "EndStateName";

                // Generate this declaration only if this
                // transition has multiple guards. If this
                // is the only guard, then this local variable
                // declaration will appear after the first
                // control statement - which is an ANSI C
                // syntax error.
                // If there is only one guard, then this code
                // is generated by visit(SmcTransition) before
                // the debug code is generated.
                // If there are multiple guards, then this code
                // appears at the start of an if, else if or else
                // code block which is acceptable ANSI C.
                if (mGuardCount > 1)
                {
                    mTarget.print(indent2);
                    mTarget.print("const struct ");
                    mTarget.print(context);
                    mTarget.print("State* ");
                    mTarget.print(fqEndStateName);
                    mTarget.println(" = getState(fsm);");
                    mTarget.println();
                }
            }
            else
            {
                fqEndStateName = endStateName;
            }
        }

        // Before doing anything else, perform the current
        // state's exit actions.
        // v. 1.0, beta 3: Not any more. The exit actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a pop transition.
        if ((map.getFSM().hasExitActions()) &&
             (transType == TransType.TRANS_POP ||
              !loopbackFlag))
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println("if (getDebugFlag(fsm) != 0) {");
                mTarget.print(indent2);
                mTarget.print("    TRACE(\"BEFORE EXIT     : ");
                mTarget.println(
                    "EXIT_STATE(getState(fsm))\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }

            mTarget.print(indent2);
            mTarget.println("EXIT_STATE(getState(fsm));");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println("if (getDebugFlag(fsm) != 0) {");
                mTarget.print(indent2);
                mTarget.print("    TRACE(\"AFTER EXIT      : ");
                mTarget.println(
                    "EXIT_STATE(getState(fsm))\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }
        }

        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            Iterator<SmcParameter> pit;
            SmcParameter param;
            String sep;

            mTarget.print(indent2);
            mTarget.println("if (getDebugFlag(fsm) != 0) {");
            mTarget.print(indent2);
            mTarget.print("    TRACE(\"ENTER TRANSITION: ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(stateName);
            mTarget.print(".");
            mTarget.print(transName);
            mTarget.print("(");

            for (pit = transition.getParameters().iterator(),
                 sep = "";
                 pit.hasNext();
                 sep = ", ")
            {
                param = pit.next();
                mTarget.print(sep);
                mTarget.print(param.getName());
            }

            mTarget.println(")\\n\");");
            mTarget.print(indent2);
            mTarget.println("}");
        }

        // Dump out this transition's actions.
        if (actions.isEmpty())
        {
            if (condition.length() > 0)
            {
                mTarget.print(indent2);
                mTarget.println("/* No actions. */");
            }
        }
        else
        {
            // Now that we are in the transition, clear the
            // current state.
            mTarget.print(indent2);
            mTarget.println("clearState(fsm);");

            indent4 = mIndent;
            mIndent = indent2;
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            mIndent = indent4;
        }
        indent3 = indent2;

        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            Iterator<SmcParameter> pit;
            SmcParameter param;
            String sep;

            mTarget.print(indent2);
            mTarget.println("if (getDebugFlag(fsm) != 0) {");
            mTarget.print(indent2);
            mTarget.print("    TRACE(\"EXIT TRANSITION : ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(stateName);
            mTarget.print(".");
            mTarget.print(transName);
            mTarget.print("(");

            for (pit = transition.getParameters().iterator(),
                 sep = "";
                 pit.hasNext();
                 sep = ", ")
            {
                param = pit.next();
                mTarget.print(sep);
                mTarget.print(param.getName());
            }

            mTarget.println(")\\n\");");
            mTarget.print(indent2);
            mTarget.println("}");
        }

        // Print the setState() call, if necessary. Do NOT
        // generate the set state if:
        // 1. The transition has no actions AND is a loopback OR
        // 2. This is a push or pop transition.
        if (transType == TransType.TRANS_SET &&
            (!actions.isEmpty() || !loopbackFlag))
        {
            mTarget.print(indent3);
            mTarget.print("setState(fsm, ");
            mTarget.print(fqEndStateName);
            mTarget.println(");");
        }
        else if (transType == TransType.TRANS_PUSH)
        {
            // Set the end state so that it can be pushed
            // onto the state stack. But only do so if a clear
            // state was done.
            if (!loopbackFlag || !actions.isEmpty())
            {
                mTarget.print(indent3);
                mTarget.print("setState(fsm, ");
                mTarget.print(fqEndStateName);
                mTarget.println(");");
            }

            // Before doing the push, execute the end state's
            // entry actions (if any) if this is not a loopback.
            if (map.getFSM().hasEntryActions() && !loopbackFlag)
            {
                if (mDebugLevel >= DEBUG_LEVEL_1)
                {
                    mTarget.print(indent3);
                    mTarget.println(
                        "if (getDebugFlag(fsm) != 0) {");
                    mTarget.print(indent3);
                    mTarget.print(
                        "    TRACE(\"BEFORE ENTRY    : ");
                    mTarget.println(
                        "ENTRY_STATE(getState(fsm))\\n\");");
                    mTarget.print(indent3);
                    mTarget.println("}");
                }

                mTarget.print(indent3);
                mTarget.println("ENTRY_STATE(getState(fsm));");

                if (mDebugLevel >= DEBUG_LEVEL_1)
                {
                    mTarget.print(indent3);
                    mTarget.println(
                        "if (getDebugFlag(fsm) != 0) {");
                    mTarget.print(indent3);
                    mTarget.print(
                        "    TRACE(\"AFTER ENTRY     : ");
                    mTarget.println(
                        "ENTRY_STATE(getState(fsm))\\n\");");
                    mTarget.print(indent3);
                    mTarget.println("}");
                }
            }

            mTarget.print(indent3);
            mTarget.print("pushState(fsm, ");
            mTarget.print(pushStateName);
            mTarget.println(");");
        }
        else if (transType == TransType.TRANS_POP)
        {
            mTarget.print(indent3);
            mTarget.println("popState(fsm);");
        }

        // Perform the new state's entry actions.
        // v. 1.0, beta 3: Not any more. The entry actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a push transition.
        if (map.getFSM().hasEntryActions() &&
            ((transType == TransType.TRANS_SET &&
              !loopbackFlag) ||
              transType == TransType.TRANS_PUSH))
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println("if (getDebugFlag(fsm) != 0) {");
                mTarget.print(indent2);
                mTarget.print("    TRACE(\"BEFORE ENTRY    : ");
                mTarget.println(
                    "ENTRY_STATE(getState(fsm))\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }

            mTarget.print(indent2);
            mTarget.println("ENTRY_STATE(getState(fsm));");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println("if (getDebugFlag(fsm) != 0) {");
                mTarget.print(indent2);
                mTarget.print("    TRACE(\"AFTER ENTRY     : ");
                mTarget.println(
                    "ENTRY_STATE(getState(fsm))\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }
        }

        // If there is a transition associated with the pop, then
        // issue that transition here.
        if (transType == TransType.TRANS_POP &&
            !endStateName.equalsIgnoreCase(SmcElement.NIL_STATE) &&
            endStateName.length() > 0)
        {
            String popArgs = guard.getPopArgs();

            mTarget.print(indent2);
            mTarget.print(fsmClassName);
            mTarget.print("_");
            mTarget.print(endStateName);
            mTarget.print("(fsm");

            // Output any and all pop arguments.
            if (popArgs.length() > 0)
            {
                mTarget.print(", ");
                mTarget.print(popArgs);
            }
            mTarget.println(");");
        }

        // If this is a guarded transition, it will be necessary
        // to close off the "if" body. DON'T PRINT A NEW LINE!
        // Why? Because an "else" or "else if" may follow and we
        // won't know until we go back to the transition target
        // generator whether all clauses have been done.
        if (mGuardCount > 1)
        {
            mTarget.print(mIndent);
            mTarget.print("    }");
        }

        return;
    } // end of visit(SmcGuard)

    /**
     * Emits C code for this FSM action. The emitted C code has
     * the format:
     * <pre>
     *   <code>
     * <i>action</i>(ctxt[, <i>arg0</i>, ... , <i>argn</i>]);
     *   </code>
     * </pre>
     * @param action emit C code for this action.
     */
    @Override
    public void visit(final SmcAction action)
    {
        String name = action.getName();

        // Need to distinguish between FSMContext actions and
        // application class actions. If the action is
        // "emptyStateStack", then pass it to the context.
        // Otherwise, let the application class handle it.
        mTarget.print(mIndent);
        if ( action.isEmptyStateStack())
        {
            mTarget.println("emptyStateStack(fsm);");
        }
        else
        {
            mTarget.print(mContext);
            mTarget.print("_");
            mTarget.print(name);
            mTarget.print("(ctxt");

            for (String arg: action.getArguments())
            {
                if (!arg.isEmpty())
               {
                    mTarget.print(", ");
                    mTarget.print(arg);
        }
            }
            mTarget.println(");");
        }

        return;
    } // end of visit(SmcAction)

    /**
     * Emits C code for this transition parameter. The emitted
     * C code has the format:
     * <pre>
     *   <code>
     * <i>type</i> <i>name</i>
     *   </code>
     * </pre>
     * @param parameter emit C code for this transition
     * parameter.
     */
    @Override
    public void visit(final SmcParameter parameter)
    {
        mTarget.print(parameter.getType());
        mTarget.print(" ");
        mTarget.print(parameter.getName());

        return;
    } // end of visit(SmcParameter)

    //
    // end of SmcVisitor Abstract Method Impelementation.
    //-----------------------------------------------------------

    /**
     * Returns the scoped state name. If the state is
     * unscoped, then returns
     * {@code <i>mapName</i>.<i>stateName</i>}. Replaces
     * any "::" with "_" in the state name.
     * @param stateName the state name.
     * @param mapName the map name.
     * @return the scoped state name.
     */
    @Override
    protected String scopeStateName(final String stateName,
                                    final String mapName)
    {
        int index;
        StringWriter retval = new StringWriter();

        index = stateName.indexOf("::");
        if (index < 0)
        {
            retval.write(mapName);
            retval.write("_");
            retval.write(stateName);
        }
        else
        {
            retval.write(stateName.substring(0, index));
            retval.write('_');
            retval.write(stateName.substring(index + 2));
        }

        return (retval.toString());
    } // end of scopeStateName(String, String)
} // end of class SmcCGenerator

//
// CHANGE LOG
// $Log: SmcCGenerator.java,v $
// Revision 1.20  2015/02/16 21:43:09  cwrapp
// SMC v. 6.5.0
//
// SMC - The State Machine Compiler v. 6.5.0
//
// Major changes:
//
// (Java)
//     Added a new "-java7" target language. This version represents
//     the FSM as a transition table. The transition table maps the
//     current state and the transition to a
//     java.lang.invoke.MethodHandle. The transition is executed by
//     calling MethodHandle.invokeExact, which is only slightly
//     slower than a compiled method call.
//
//     The -java7 generated code is compatible with -java generated
//     code. This allows developers to switch between the two
//     without changing application code.
//
//     NOTE: -java7 requires Java 1.7 or latter to run.
//
//
// Minor changes:
//
// (None.)
//
//
// Bug Fixes:
//
// (Objective-C)
//     Incorrect initWithOwner body generated. Same fundamental
//     problem as SF bug 200. See below.
//     (SF bug 198)
//
// (Website)
//     Corrected broken link in FAQ page.
//     (SF bug 199)
//
// (C++)
//     Corrected the invalid generated FSM class name.
//     (SF bug 200)
//
// (C)
//     EXIT_STATE() #define macro not generated.
//     (SF bug 201)
//
// (Manual)
//     Corrected examples which showed %fsmclass and %map set to the
//     same name. This is invalid for most target languages since
//     that would mean the nested map class would have the same name
//     as the containing FSM class.
//
//
//
// ++++++++++++++++++++++++++++++++++++++++
//
// If you have any questions or bugs, please surf
// over to http://smc.sourceforge.net and check out
// the discussion and bug forums. Note: you must be
// a SourceForge member to add articles or bugs. You
// do not have to be a member to read posted
// articles or bugs.
//
// Revision 1.19  2015/02/06 16:33:02  fperrad
// fix http://sourceforge.net/p/smc/bugs/201/
//
// Revision 1.18  2014/09/28 15:41:19  cwrapp
// SMC 6.4.0 release.
//
// Revision 1.17  2014/08/30 07:12:41  fperrad
// refactor C generation
//
// Revision 1.16  2013/07/14 14:32:37  cwrapp
// check in for release 6.2.0
//
// Revision 1.15  2012/05/13 16:31:10  fperrad
// fix 3525846 : endless recursion with guarded transitions in Default state
//
// Revision 1.14  2012/01/28 18:03:02  fperrad
// fix 3476060 : generate both C functions and macros
//
// Revision 1.13  2010/12/01 15:29:09  fperrad
// C: refactor when package
//
// Revision 1.12  2010/09/21 08:16:00  fperrad
// refactor C generation
//
// Revision 1.11  2010/09/11 19:15:57  fperrad
// remove \r from debug message
//
// Revision 1.10  2010/02/15 18:05:41  fperrad
// fix 2950619 : make distinction between target filename (*.sm) and target filename.
//
// Revision 1.9  2009/12/17 19:51:43  cwrapp
// Testing complete.
//
// Revision 1.8  2009/11/25 22:30:19  cwrapp
// Fixed problem between %fsmclass and sm file names.
//
// Revision 1.7  2009/11/24 20:42:39  cwrapp
// v. 6.0.1 update
//
// Revision 1.6  2009/10/06 15:31:59  kgreg99
// 1. Started implementation of feature request #2718920.
//     1.1 Added method boolean isStatic() to SmcAction class. It returns false now, but is handled in following language generators: C#, C++, java, php, VB. Instance identificator is not added in case it is set to true.
// 2. Resolved confusion in "emtyStateStack" keyword handling. This keyword was not handled in the same way in all the generators. I added method boolean isEmptyStateStack() to SmcAction class. This method is used instead of different string comparisons here and there. Also the generated method name is fixed, not to depend on name supplied in the input sm file.
//
// Revision 1.5  2009/09/12 21:44:49  kgreg99
// Implemented feature req. #2718941 - user defined generated class name.
// A new statement was added to the syntax: %fsmclass class_name
// It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
// If used, generated class is called asrequested.
// Following language generators are touched:
// c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
// This feature is not tested yet !
// Maybe it will be necessary to modify also the output file name.
//
// Revision 1.4  2009/09/05 15:39:20  cwrapp
// Checking in fixes for 1944542, 1983929, 2731415, 2803547 and feature 2797126.
//
// Revision 1.3  2009/03/27 15:26:55  fperrad
// C : the function Context_EnterStartState is generated only if FSM hasEntryActions
//
// Revision 1.2  2009/03/27 09:41:47  cwrapp
// Added F. Perrad changes back in.
//
// Revision 1.1  2009/03/01 18:20:42  cwrapp
// Preliminary v. 6.0.0 commit.
//
//
