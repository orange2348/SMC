//
// The contents of this file are subject to the Mozilla Public
// License Version 1.1 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy
// of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an
// "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//
// The Original Code is State Machine Compiler (SMC).
//
// The Initial Developer of the Original Code is Charles W. Rapp.
// Portions created by Charles W. Rapp are
// Copyright (C) 2005, 2008. Charles W. Rapp.
// All Rights Reserved.
//
// Contributor(s):
//   Eitan Suez contributed examples/Ant.
//   (Name withheld) contributed the C# code generation and
//   examples/C#.
//   Francois Perrad contributed the Python code generation and
//   examples/Python.
//   Chris Liscio contributed the Objective-C code generation
//   and examples/ObjC.
//
// RCS ID
// Id: SmcHeaderGenerator.java,v 1.10 2015/02/16 21:43:09 cwrapp Exp
//
// CHANGE LOG
// (See the bottom of this file.)
//

package net.sf.smc.generator;

import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement;
import net.sf.smc.model.SmcFSM;
import net.sf.smc.model.SmcMap;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.SmcState;
import net.sf.smc.model.SmcTransition;
import net.sf.smc.model.SmcVisitor;

/**
 * Visits the abstract syntax tree emitting a C++ header file.
 * @see SmcElement
 * @see SmcVisitor
 * @see SmcCppGenerator
 * @see SmcOptions
 *
 * @author <a href="mailto:rapp@acm.org">Charles Rapp</a>
 */

public final class SmcHeaderGenerator
    extends SmcCodeGenerator
{
//---------------------------------------------------------------
// Member data
//

//---------------------------------------------------------------
// Member methods
//

    //-----------------------------------------------------------
    // Constructors.
    //

    /**
     * Creates a C++ header code generator for the given options.
     * @param options command line options.
     */
    public SmcHeaderGenerator(final SmcOptions options)
    {
        super (options, DEFAULT_HEADER_SUFFIX);
    } // end of SmcHeaderGenerator(SmcOptions)

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // SmcVisitor Abstract Method Impelementation.
    //

    /**
     * Emits C++ header code for the finite state machine.
     * @param fsm emit C=+ header code for this finite state
     * machine.
     */
    @Override
    public void visit(SmcFSM fsm)
    {
        String targetfileCaps;
        String packageName = fsm.getPackage();
        String context = fsm.getContext();
        String fsmClassName = fsm.getFsmClassName();
        String mapName;
        List<SmcTransition> transList;
        String separator;
        List<SmcParameter> params;
        Iterator<SmcParameter> pit;
        int packageDepth = 0;

        mTarget.println("//");
        mTarget.println("// ex: set ro:");
        mTarget.println("// DO NOT EDIT.");
        mTarget.println("// generated by smc (http://smc.sourceforge.net/)");
        mTarget.print("// from file : ");
        mTarget.print(mSrcfileBase);
        mTarget.println(".sm");
        mTarget.println("//");
        mTarget.println();

        // The first two lines in the header file should be:
        //
        //    #ifndef <source file name>_H
        //    #define <source file name>_H
        //
        // where the target file name is all in caps.
        // The last line is:
        //
        //    #endif
        //

        // Make the file name upper case and replace
        // slashes with underscores.
        targetfileCaps = mTargetfileBase.replace('\\', '_');
        targetfileCaps = targetfileCaps.replace('/', '_');
        targetfileCaps = targetfileCaps.toUpperCase();
        mTarget.print("#ifndef ");
        mTarget.print(targetfileCaps);
        mTarget.println("_H");
        mTarget.print("#define ");
        mTarget.print(targetfileCaps);
        mTarget.println("_H");
        mTarget.println();

        // If this application *is* using iostreams to output
        // debug messages, then define SMC_USES_IOSTREAMS.
        // Otherwise the user is responsible for providing a
        // TRACE macro to output the debug messages.
        if (mNoStreamsFlag == false)
        {
            mTarget.println();
            mTarget.println("#define SMC_USES_IOSTREAMS");
        }

        // If this application is *not* using exceptions, then
        // define SMC_NO_EXCEPTIONS.
        if (mNoExceptionFlag)
        {
            mTarget.println();
            mTarget.println("#define SMC_NO_EXCEPTIONS");
        }

        // If this application is using static memory only, then
        // define SMC_FIXED_STACK and SMC_STATE_STACK_SIZE.
        if (mStateStackSize > 0)
        {
            mTarget.println();
            mTarget.println("#define SMC_FIXED_STACK");
            mTarget.println("#define SMC_STATE_STACK_SIZE " +
                            mStateStackSize);
        }

        // Include required standard .h files.
        mTarget.println();
        mTarget.println("#include <statemap.h>");

        mTarget.println();

        // If a namespace was specified, then output that
        // namespace now. If the package name is "a::b::c", then
        // this must be converted to:
        // namespace a {
        //   namespace b {
        //     namespace c {
        //       ...
        //     }
        //   }
        // }
        mIndent = "";
        if (packageName != null && packageName.length() > 0)
        {
            StringTokenizer tokenizer =
                new StringTokenizer(packageName, "::");
            String token;

            while (tokenizer.hasMoreTokens())
            {
                token = tokenizer.nextToken();
                ++packageDepth;

                mTarget.print(mIndent);
                mTarget.print("namespace ");
                mTarget.println(token);
                mTarget.print(mIndent);
                mTarget.println("{");
                mIndent += "    ";
            }
        }

        // Forward declare all the state classes in all the maps.
        mTarget.print(mIndent);
        mTarget.println("// Forward declarations.");
        for (SmcMap map: fsm.getMaps())
        {
            mapName = map.getName();

            // class <map name>;
            mTarget.print(mIndent);
            mTarget.print("class ");
            mTarget.print(mapName);
            mTarget.println(";");

            // Iterate over the map's states.
            for (SmcState state: map.getStates())
            {
                mTarget.print(mIndent);
                mTarget.print("class ");
                mTarget.print(mapName);
                mTarget.print("_");
                mTarget.print(state.getClassName());
                mTarget.println(";");
            }

            // Forward declare the default state as well.
            mTarget.print(mIndent);
            mTarget.print("class ");
            mTarget.print(mapName);
            mTarget.println("_Default;");
        }

        // Forward declare the state class and its
        // context as well.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(context);
        mTarget.println("State;");
        mTarget.print(mIndent);
        if (mCRTPFlag)
        {
            mTarget.print("template<typename DERIVED> ");
        }
        mTarget.print("class ");
        mTarget.print(fsmClassName);
        mTarget.println(";");

        // Forward declare the application class.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(context);
        mTarget.println(";");

        // Do user-specified forward declarations now.
        for (String declaration: fsm.getDeclarations())
        {
            mTarget.print(mIndent);
            mTarget.print(declaration);
            mTarget.println();
        }
        mTarget.println();

        // Declare user's base state class.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(context);
        mTarget.println("State :");
        mTarget.print(mIndent);
        mTarget.println("    public statemap::State");
        mTarget.print(mIndent);
        mTarget.println("{");
        mTarget.print(mIndent);
        mTarget.println("public:");
        mTarget.println();

        // Constructor.
        mTarget.print(mIndent);
        mTarget.print("    ");
        mTarget.print(context);
        mTarget.println("State(const char * const name, const int stateId)");
        mTarget.print(mIndent);
        mTarget.println("    : statemap::State(name, stateId)");
        mTarget.print(mIndent);
        mTarget.println("    {};");
        mTarget.println();

        // Add the default Entry() and Exit() definitions.
        mTarget.print(mIndent);
        mTarget.print("    virtual void Entry(");
        mTarget.print(fsmClassName);
        if (mCRTPFlag)
        {
            mTarget.print("<");
            mTarget.print(context);
            mTarget.print(">");
        }
        mTarget.println("&) {};");
        mTarget.print(mIndent);
        mTarget.print("    virtual void Exit(");
        mTarget.print(fsmClassName);
        if (mCRTPFlag)
        {
            mTarget.print("<");
            mTarget.print(context);
            mTarget.print(">");
        }
        mTarget.println("&) {};");
        mTarget.println();

        // Print out the default definitions for all the
        // transitions. First, get the transitions list.
        transList = fsm.getTransitions();

        // Output the global transition declarations.
        for (SmcTransition trans: transList)
        {
            // Don't output the default state here.
            if (trans.getName().equals("Default") == false)
            {
                mTarget.print(mIndent);
                mTarget.print("    virtual void ");
                mTarget.print(trans.getName());
                mTarget.print("(");
                mTarget.print(fsmClassName);
                if (mCRTPFlag)
                {
                    mTarget.print("<");
                    mTarget.print(context);
                    mTarget.print(">");
                }
                mTarget.print("& context");

                params = trans.getParameters();
                for (SmcParameter param: params)
                {
                    mTarget.print(", ");
                    param.accept(this);
                }

                mTarget.println(");");
            }
        }

        // Declare the global Default transition.
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("protected:");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("    virtual void Default(");
        mTarget.print(fsmClassName);
        if (mCRTPFlag)
        {
            mTarget.print("<");
            mTarget.print(context);
            mTarget.print(">");
        }
        mTarget.println("& context);");

        // The base class has been defined.
        mTarget.print(mIndent);
        mTarget.println("};");
        mTarget.println();

        // Generate the map classes. The maps will, in turn,
        // generate the state classes.
        for (SmcMap map: fsm.getMaps())
        {
            map.accept(this);
        }

        // Generate the FSM context class.
        // class FooContext :
        //     public statemap::FSMContext
        // {
        // public:
        //     FOOContext(FOO& owner)
        //     virtual void enterStartState()
        //
        mTarget.print(mIndent);
        if (mCRTPFlag)
        {
            mTarget.println("template<typename DERIVED>");
        }
        mTarget.print("class ");
        mTarget.print(fsmClassName);
        mTarget.println(" :");
        mTarget.print(mIndent);
        mTarget.println("    public statemap::FSMContext");
        mTarget.print(mIndent);
        mTarget.println("{");
        mTarget.print(mIndent);
        mTarget.println("public:");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("    explicit ");
        mTarget.print(fsmClassName);
        mTarget.print("(");
        if (mCRTPFlag == false)
        {
            mTarget.print(context);
            mTarget.print("& owner");
        }
        mTarget.println(")");
        mTarget.print(mIndent);
        mTarget.print("    : FSMContext(");
        mTarget.print(fsm.getStartState());
        mTarget.print(")");
        if (mCRTPFlag == false)
        {
            mTarget.println(",");
            mTarget.print(mIndent);
            mTarget.println("      _owner(owner)");
        }
        else
        {
            mTarget.println();
        }
        mTarget.print(mIndent);
        mTarget.println("    {};");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("    ");
        mTarget.print(fsmClassName);
        mTarget.print("(");
        if (mCRTPFlag == false)
        {
            mTarget.print(context);
            mTarget.print("& owner, ");
        }
        mTarget.println("const statemap::State& state)");
        mTarget.print(mIndent);
        mTarget.print("    : FSMContext(state)");
        if (mCRTPFlag == false)
        {
            mTarget.println(",");
            mTarget.print(mIndent);
            mTarget.println("      _owner(owner)");
        }
        else
        {
            mTarget.println();
        }
        mTarget.print(mIndent);
        mTarget.println("    {};");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("    virtual void enterStartState()");
        mTarget.print(mIndent);
        mTarget.println("    {");
        mTarget.print(mIndent);
        mTarget.println("        getState().Entry(*this);");
        mTarget.print(mIndent);
        mTarget.println("        return;");
        mTarget.print(mIndent);
        mTarget.println("    }");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("    inline ");
        mTarget.print(context);
        mTarget.println("& getOwner()");
        mTarget.print(mIndent);
        mTarget.println("    {");
        mTarget.print(mIndent);
        if (mCRTPFlag)
        {
            mTarget.println("        return (*static_cast<DERIVED*>(this));");
        }
        else
        {
            mTarget.println("        return (_owner);");
        }
        mTarget.print(mIndent);
        mTarget.println("    };");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("    inline ");
        mTarget.print(context);
        mTarget.println("State& getState()");
        mTarget.print(mIndent);
        mTarget.println("    {");

        // v. 1.3.1: If -noex was specified, then don't throw
        // exceptions.
        if (mNoExceptionFlag == false)
        {
            mTarget.print(mIndent);
            mTarget.println("        if (_state == NULL)");
            mTarget.print(mIndent);
            mTarget.println("        {");
            mTarget.print(mIndent);
            mTarget.print("            throw ");
            mTarget.println(
                "statemap::StateUndefinedException();");
            mTarget.print(mIndent);
            mTarget.println("        }");
        }
        else
        {
            mTarget.print(mIndent);
            mTarget.println("        assert(_state != NULL);");
        }

        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("        return ");
        mTarget.print(mCastType);
        mTarget.print("<");
        mTarget.print(context);
        mTarget.println("State&>(*_state);");
        mTarget.print(mIndent);
        mTarget.println("    };");

        // Generate a method for every transition in every map
        // *except* the default transition.
        for (SmcTransition trans: transList)
        {
            if (trans.getName().equals("Default") == false)
            {
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.print("    inline void ");
                mTarget.print(trans.getName());
                mTarget.print("(");

                params = trans.getParameters();
                for (pit = params.iterator(),
                       separator = "";
                     pit.hasNext();
                     separator = ", ")
                {
                    mTarget.print(separator);
                    (pit.next()).accept(this);
                }
                mTarget.println(")");
                mTarget.print(mIndent);
                mTarget.println("    {");

                // If -g was specified, then set the transition
                // name so it can be printed out.
                if (mDebugLevel >= DEBUG_LEVEL_0)
                {
                    mTarget.print(mIndent);
                    mTarget.print("        setTransition(\"");
                    mTarget.print(trans.getName());
                    mTarget.println("\");");
                }

                mTarget.print(mIndent);
                mTarget.print("        getState().");
                mTarget.print(trans.getName());
                mTarget.print("(*this");
                for (SmcParameter param: params)
                {
                    mTarget.print(", ");
                    mTarget.print(param.getName());
                }
                mTarget.println(");");

                if (mDebugLevel >= DEBUG_LEVEL_0)
                {
                    mTarget.print(mIndent);
                    mTarget.println(
                        "        setTransition(NULL);");
                }

                mTarget.print(mIndent);
                mTarget.println("    };");
            }
        }

        // v. 2.2.0: If we are supporting serialization, then
        // declare the valueOf static method.
        if (mSerialFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.print("    static ");
            mTarget.print(context);
            mTarget.println("State& valueOf(int stateId);");
        }

        if (mCRTPFlag == false)
        {
            // Member data.
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("private:");
            mTarget.print(mIndent);
            mTarget.print("    ");
            mTarget.print(context);
            mTarget.println("& _owner;");
        }

        // v. 2.2.0: If we are supporting serialization, then
        // declare the min and max indices.
        if (mSerialFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("private:");
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("    const static int MIN_INDEX;");
            mTarget.print(mIndent);
            mTarget.println("    const static int MAX_INDEX;");
            mTarget.print(mIndent);
            mTarget.print("    static ");
            mTarget.print(context);
            mTarget.println("State* _States[];");
        }

        // Put the closing brace on the context class.
        mTarget.print(mIndent);
        mTarget.println("};");

        // If necessary, place an end brace for the namespace.
        if (packageName != null && packageName.length() > 0)
        {
            int i;
            int j;

            for (i = (packageDepth - 1); i >= 0; --i)
            {
                // Output the proper indent.
                for (j = 0; j < i; ++j)
                {
                    mTarget.print("    ");
                }

                mTarget.println("}");
                mTarget.println();
            }
        }
        else
        {
            mTarget.println();
        }

        mTarget.println();
        mTarget.print("#endif // ");
        mTarget.print(targetfileCaps);
        mTarget.println("_H");

        mTarget.println();
        mTarget.println("//");
        mTarget.println("// Local variables:");
        mTarget.println("//  buffer-read-only: t");
        mTarget.println("// End:");
        mTarget.println("//");

        return;
    } // end of visit(SmcFSM)

    /**
     * Generates the map class declaration and then the state
     * classes:
     * <pre>
     *   <code>
     * class <i>map name</i>
     * {
     * public:
     *
     *     static <i>map name</i>_<i>state name</i> <i>state name</i>;
     * };
     *   </code>
     * </pre>
     * @param map emit C++ header code for this map.
     */
    //
    //
    @Override
    public void visit(SmcMap map)
    {
        String context = map.getFSM().getContext();
        String mapName = map.getName();
        String stateName;

        // Forward declare the map.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.println(mapName);
        mTarget.print(mIndent);
        mTarget.println("{");
        mTarget.print(mIndent);
        mTarget.println("public:");
        mTarget.println();

        // Iterate over the map's states and declare the static,
        // singleton state instances
        for (SmcState state: map.getStates())
        {
            stateName = state.getClassName();

            mTarget.print(mIndent);
            mTarget.print("    static ");
            mTarget.print(mapName);
            mTarget.print("_");
            mTarget.print(stateName);
            mTarget.print(" ");
            mTarget.print(stateName);
            mTarget.println(";");
        }

        // The map class is now defined.
        mTarget.print(mIndent);
        mTarget.println("};");
        mTarget.println();

        // Declare the map's default state class.
        //
        // class <map name>_Default :
        //     public <context>State
        // {
        // public:
        //
        //     <map name>_Default(const char * const name, const int stateId)
        //     : <context>State(name, stateId)
        //     {};
        //
        //     (user-defined Default state transitions.)
        // };
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.println("_Default :");
        mTarget.print(mIndent);
        mTarget.print("    public ");
        mTarget.print(context);
        mTarget.println("State");
        mTarget.print(mIndent);
        mTarget.println("{");
        mTarget.print(mIndent);
        mTarget.println("public:");
        mTarget.println();

        // Default state's constructor.
        mTarget.print(mIndent);
        mTarget.print("    ");
        mTarget.print(mapName);
        mTarget.println(
            "_Default(const char * const name, const int stateId)");
        mTarget.print(mIndent);
        mTarget.print("    : ");
        mTarget.print(context);
        mTarget.println("State(name, stateId)");
        mTarget.print(mIndent);
        mTarget.println("    {};");
        mTarget.println();

        // Declare the user-defined default transitions first.
        if (map.hasDefaultState())
        {
            SmcState defaultState = map.getDefaultState();

            for (SmcTransition transition:
                     defaultState.getTransitions())
            {
                transition.accept(this);
            }
        }

        // The map's default state class is now defined.
        mTarget.print(mIndent);
        mTarget.println("};");
        mTarget.println();

        // Now output the state class declarations.
        for (SmcState state: map.getStates())
        {
            state.accept(this);
        }

        return;
    } // end of visit(SmcMap)

    /**
     * Generates the state's class declaration:
     * <pre>
     *   <code>
     * class <i>map name</i>_<i>state name</i> :
     *     public <i>map name</i>_Default
     * {
     * public:
     *
     *     <i>map name</i>_<i>state name</i>(const char * const name, const int stateId)
     *     : <i>map name</i>_Default(name, stateId)
     *     {};
     *
     *     (declare the transition methods.)
     *     void <i>transition name</i>(<i>context</i>&amp; context, <i>args</i>);
     * };
     *   </code>
     * </pre>
     * @param state emits C++ header code for this state.
     */
    @Override
    public void visit(SmcState state)
    {
        SmcMap map = state.getMap();
        String context = map.getFSM().getContext();
        String fsmClassName = map.getFSM().getFsmClassName();
        String mapName = map.getName();
        String stateName = state.getClassName();
        List<SmcAction> actions;

        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.print('_');
        mTarget.print(stateName);
        mTarget.println(" :");
        mTarget.print(mIndent);
        mTarget.print("    public ");
        mTarget.print(mapName);
        mTarget.println("_Default");
        mTarget.print(mIndent);
        mTarget.println("{");
        mTarget.print(mIndent);
        mTarget.print("public:");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("    ");
        mTarget.print(mapName);
        mTarget.print('_');
        mTarget.print(stateName);
        mTarget.println("(const char * const name, const int stateId)");
        mTarget.print(mIndent);
        mTarget.print("    : ");
        mTarget.print(mapName);
        mTarget.println("_Default(name, stateId)");
        mTarget.print(mIndent);
        mTarget.println("    {};");
        mTarget.println();

        // Add the Entry() and Exit() methods if this state
        // defines them.
        actions = state.getEntryActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.print(mIndent);
            mTarget.print("    virtual void Entry(");
            mTarget.print(fsmClassName);
            if (mCRTPFlag)
            {
                mTarget.print("<");
                mTarget.print(context);
                mTarget.print(">");
            }
            mTarget.println("&);");
        }

        actions = state.getExitActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.print(mIndent);
            mTarget.print("    virtual void Exit(");
            mTarget.print(fsmClassName);
            if (mCRTPFlag)
            {
                mTarget.print("<");
                mTarget.print(context);
                mTarget.print(">");
            }
            mTarget.println("&);");
        }

        // Now generate the transition methods.
        for (SmcTransition transition: state.getTransitions())
        {
            transition.accept(this);
        }

        // End of the state class declaration.
        mTarget.print(mIndent);
        mTarget.println("};");
        mTarget.println();

        return;
    } // end of visit(SmcState)

    /**
     * Generates the transition method declaration:
     * <pre>
     *   <code>
     * void <i>transition name</i>(<i>context</i>Context&amp; context, <i>args</i>);
     *   </code>
     * </pre>
     * @param transition emits C++ header code for this state
     * transition.
     */
    @Override
    public void visit(SmcTransition transition)
    {
        SmcState state = transition.getState();

        mTarget.print(mIndent);
        mTarget.print("    virtual void ");
        mTarget.print(transition.getName());
        mTarget.print("(");
        mTarget.print(state.getMap().getFSM().getFsmClassName());
        if (mCRTPFlag)
        {
            mTarget.print("<");
            mTarget.print(state.getMap().getFSM().getContext());
            mTarget.print(">");
        }
        mTarget.print("& context");

        // Add user-defined parameters.
        for (SmcParameter param: transition.getParameters())
        {
            mTarget.print(", ");
            param.accept(this);
        }

        // End of transition method declaration.
        mTarget.println(");");

        return;
    } // end of visit(SmcTransition)

    /**
     * Emits C++ header code for this transition parameter.
     * @param parameter emits C++ header code for this transition
     * parameter.
     */
    @Override
    public void visit(SmcParameter parameter)
    {
        mTarget.print(parameter.getType());
        mTarget.print(" ");
        mTarget.print(parameter.getName());

        return;
    } // end of visit(SmcParameter)

    //
    // end of SmcVisitor Abstract Method Impelementation.
    //-----------------------------------------------------------
} // end of class SmcHeaderGenerator

//
// CHANGE LOG
// Log: SmcHeaderGenerator.java,v
// Revision 1.10  2015/02/16 21:43:09  cwrapp
// SMC v. 6.5.0
//
// SMC - The State Machine Compiler v. 6.5.0
//
// Major changes:
//
// (Java)
//     Added a new "-java7" target language. This version represents
//     the FSM as a transition table. The transition table maps the
//     current state and the transition to a
//     java.lang.invoke.MethodHandle. The transition is executed by
//     calling MethodHandle.invokeExact, which is only slightly
//     slower than a compiled method call.
//
//     The -java7 generated code is compatible with -java generated
//     code. This allows developers to switch between the two
//     without changing application code.
//
//     NOTE: -java7 requires Java 1.7 or latter to run.
//
//
// Minor changes:
//
// (None.)
//
//
// Bug Fixes:
//
// (Objective-C)
//     Incorrect initWithOwner body generated. Same fundamental
//     problem as SF bug 200. See below.
//     (SF bug 198)
//
// (Website)
//     Corrected broken link in FAQ page.
//     (SF bug 199)
//
// (C++)
//     Corrected the invalid generated FSM class name.
//     (SF bug 200)
//
// (C)
//     EXIT_STATE() #define macro not generated.
//     (SF bug 201)
//
// (Manual)
//     Corrected examples which showed %fsmclass and %map set to the
//     same name. This is invalid for most target languages since
//     that would mean the nested map class would have the same name
//     as the containing FSM class.
//
//
//
// ++++++++++++++++++++++++++++++++++++++++
//
// If you have any questions or bugs, please surf
// over to http://smc.sourceforge.net and check out
// the discussion and bug forums. Note: you must be
// a SourceForge member to add articles or bugs. You
// do not have to be a member to read posted
// articles or bugs.
//
// Revision 1.9  2014/09/13 06:25:32  fperrad
// refactor C++ generation
//
// Revision 1.8  2012/04/21 10:04:06  fperrad
// fix 3518773 : remove additional ';' with '%declare'
//
// Revision 1.7  2010/02/15 18:05:43  fperrad
// fix 2950619 : make distinction between target filename (*.sm) and target filename.
//
// Revision 1.6  2009/11/25 22:30:19  cwrapp
// Fixed problem between %fsmclass and sm file names.
//
// Revision 1.5  2009/11/24 20:42:39  cwrapp
// v. 6.0.1 update
//
// Revision 1.4  2009/09/12 21:44:49  kgreg99
// Implemented feature req. #2718941 - user defined generated class name.
// A new statement was added to the syntax: %fsmclass class_name
// It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
// If used, generated class is called asrequested.
// Following language generators are touched:
// c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
// This feature is not tested yet !
// Maybe it will be necessary to modify also the output file name.
//
// Revision 1.3  2009/09/05 15:39:20  cwrapp
// Checking in fixes for 1944542, 1983929, 2731415, 2803547 and feature 2797126.
//
// Revision 1.2  2009/03/27 09:41:47  cwrapp
// Added F. Perrad changes back in.
//
// Revision 1.1  2009/03/01 18:20:42  cwrapp
// Preliminary v. 6.0.0 commit.
//
//
