//
// The contents of this file are subject to the Mozilla Public
// License Version 1.1 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy
// of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an
// "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//
// The Original Code is State Machine Compiler (SMC).
//
// The Initial Developer of the Original Code is Charles W. Rapp.
// Portions created by Charles W. Rapp are
// Copyright (C) 2005 - 2009, 2019. Charles W. Rapp.
// All Rights Reserved.
//
// Port to JavaScript by Francois Perrad
// All Rights Reserved.
//
// Contributor(s):
//
// RCS ID
// $Id: SmcJSGenerator.java,v 1.5 2013/12/15 16:32:06 fperrad Exp $
//
// CHANGE LOG
// (See the bottom of this file.)
//

package net.sf.smc.generator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcFSM;
import net.sf.smc.model.SmcGuard;
import net.sf.smc.model.SmcMap;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.SmcState;
import net.sf.smc.model.SmcTransition;
import net.sf.smc.model.SmcVisitor;
import net.sf.smc.model.TargetLanguage;

/**
 * Visits the abstract syntax tree, emitting Java code.
 * @see SmcElement
 * @see SmcCodeGenerator
 * @see SmcVisitor
 * @see SmcOptions
 *
 * @author Francois Perrad
 */

public final class SmcJSGenerator
    extends SmcCodeGenerator
{
//---------------------------------------------------------------
// Member data
//

//---------------------------------------------------------------
// Member methods
//

    //-----------------------------------------------------------
    // Constructors.
    //

    /**
     * Creates a Java code generator for the given options.
     * @param options The target code generator options.
     */
    public SmcJSGenerator(final SmcOptions options)
    {
        super (options, TargetLanguage.JS.suffix());
    } // end of SmcJSGenerator(SmcOptions)

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // SmcVisitor Abstract Method Impelementation.
    //

    /**
     * Emits JavaScript code for the finite state machine context
     * class.
     * @param fsm emit JavaScript code for this finite state machine.
     */
    @Override
    public void visit(final SmcFSM fsm)
    {
        String rawSource = fsm.getSource();
        String context = fsm.getContext();
        String fsmClassName = fsm.getFsmClassName();
        String startState = fsm.getStartState();
        List<SmcMap> maps = fsm.getMaps();
        List<SmcTransition> transitions = fsm.getTransitions();
        Iterator<SmcParameter> pit;
        String transName;
        String javaState;
        String separator;
        int index;
        List<SmcParameter> params;

        mTarget.println("/*");
        mTarget.println(" * ex: set ro:");
        mTarget.println(" * DO NOT EDIT.");
        mTarget.println(" * generated by smc (http://smc.sourceforge.net/)");
        mTarget.print(" * from file : ");
        mTarget.print(mSrcfileBase);
        mTarget.println(".sm");
        mTarget.println(" */");
        mTarget.println();

        // Dump out the raw target code, if any.
        if (rawSource != null && rawSource.length() > 0)
        {
            mTarget.println(rawSource);
            mTarget.println();
        }

        // Do user-specified imports now.
        for (String imp: fsm.getImports())
        {
            mTarget.print("require('");
            mTarget.print(imp);
            mTarget.println("');");
        }

        // Declare the abstract state class.
        mTarget.println();
        mTarget.print("function ");
        mTarget.print(context);
        mTarget.println("State () {}");
        // Inheritance.
        mTarget.print(context);
        mTarget.println("State.prototype = new State();");
        mTarget.println();

        mTarget.println("var _empty = function () {};");
        mTarget.print(context);
        mTarget.println("State.prototype.Entry = _empty;");
        mTarget.print(context);
        mTarget.println("State.prototype.Exit = _empty;");
        mTarget.println();

        mTarget.println("var _default = function (fsm) {");
        mTarget.println("    this.Default(fsm);");
        mTarget.println("};");

        // Generate the default transition definitions.
        for (SmcTransition trans: transitions)
        {
            transName = trans.getName();

            // Don't generate the Default transition here.
            if (transName.equals("Default") == false)
            {
                mTarget.print(context);
                mTarget.print("State.prototype.");
                mTarget.print(transName);
                mTarget.println(" = _default;");
            }
        }

        // Generate the overall Default transition for all maps.
        mTarget.println();
        mTarget.print(context);
        mTarget.println("State.prototype.Default = function (fsm) {");

        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            mTarget.println("    if (fsm.debugFlag) {");
            mTarget.println("        fsm.debugStream.write(\"TRANSITION      : Default\\n\");");
            mTarget.println("    }");
        }

        mTarget.println("    var msg = \"Undefined Transition\\nState: \"");
        mTarget.println("            + fsm.getState().name");
        mTarget.println("            + \"\\nTransition: \"");
        mTarget.println("            + fsm.transition");
        mTarget.println("            + \"\\n\";");
        mTarget.println("    throw new Error(msg);");
        mTarget.println("};");
        mTarget.println();

        // Abstract method to obtain the a state's supported
        // transitions.
        if (mReflectFlag)
        {
            mTarget.print(context);
            mTarget.println("State.prototype.getTransitions = function () {");
            mTarget.println("    return this.transitions;");
            mTarget.println("};");
            mTarget.println();
        }

        // Have each map print out its target code now.
        for (SmcMap map: maps)
        {
            map.accept(this);
        }

        mTarget.println();

        // The state name "map::state" must be changed to
        // "map.state".
        if ((index = startState.indexOf("::")) >= 0)
        {
            javaState =
                startState.substring(0, index) +
                "." +
                startState.substring(index + 2);
        }
        else
        {
            javaState = startState;
        }

        // Generate the context class' constructor.
        mTarget.print("function ");
        mTarget.print(fsmClassName);
        mTarget.println(" (owner) {");
        mTarget.print("    FSMContext.call(this, ");
        mTarget.print(javaState);
        mTarget.println(");");
        mTarget.println("    this.owner = owner;");
        mTarget.println('}');
        // Inheritance.
        mTarget.print(fsmClassName);
        mTarget.println(".prototype = new FSMContext();");
        // Register in global.
        mTarget.println("try {");
        mTarget.print("    global.");
        mTarget.print(fsmClassName);
        mTarget.print(" = ");
        mTarget.print(fsmClassName);
        mTarget.println(';');
        mTarget.println("} catch (ex) {}");
        mTarget.println();

        // Generate the start abstract method which requires
        // executes the initial state's entry actions.
        mTarget.print(fsmClassName);
        mTarget.println(".prototype.enterStartState = function () {");
        mTarget.println("    this.getState().Entry(this);");
        mTarget.println("};");
        mTarget.println();

        // Generate the default transition methods.
        for (SmcTransition trans: transitions)
        {
            if (trans.getName().equals("Default") == false)
            {
                mTarget.print(fsmClassName);
                mTarget.print(".prototype.");
                mTarget.print(trans.getName());
                mTarget.print(" = function (");

                params = trans.getParameters();
                for (pit = params.iterator(), separator = "";
                     pit.hasNext();
                     separator = ", ")
                {
                    mTarget.print(separator);
                    (pit.next()).accept(this);
                }
                mTarget.println(") {");

                // Save away the transition name in case it is
                // need in an UndefinedTransitionException.
                mTarget.print("    this.transition = '");
                mTarget.print(trans.getName());
                mTarget.println("';");

                mTarget.print("    this.getState().");
                mTarget.print(trans.getName());
                mTarget.print("(this");

                for (pit = params.iterator();
                     pit.hasNext();
                    )
                {
                    mTarget.print(", ");
                    mTarget.print((pit.next()).getName());
                }
                mTarget.println(");");
                mTarget.println("    this.transition = '';");

                mTarget.println("};");
                mTarget.println();
            }
        }

        if (mReflectFlag)
        {
            String mapName;

            // create the state array.
            mTarget.print(fsmClassName);
            mTarget.println(".prototype.states = [");

            separator = "";
            for (SmcMap map: maps)
            {
                mapName = map.getName();

                for (SmcState state: map.getStates())
                {
                    mTarget.print(separator);
                    mTarget.print("    ");
                    mTarget.print(mapName);
                    mTarget.print(".");
                    mTarget.print(state.getClassName());

                    separator = ",\n";
                }
            }

            mTarget.println();
            mTarget.println("];");

            // getStates() method.
            mTarget.print(fsmClassName);
            mTarget.println(".prototype.getStates = function () {");
            mTarget.println("    return this.prototype.states;");
            mTarget.println("};");
            mTarget.println();

            // create the transition array.
            mTarget.print(fsmClassName);
            mTarget.println(".prototype.transitions = [");

            separator = "";
            for (SmcTransition trans: transitions)
            {
                mTarget.print(separator);
                mTarget.print("    '");
                mTarget.print(trans.getName());
                mTarget.print("'");

                separator = ",\n";
            }

            mTarget.println();
            mTarget.println("];");

            // getTransitions() method.
            mTarget.print(fsmClassName);
            mTarget.println(".prototype.getTransitions = function () {");
            mTarget.println("    return this.prototype.transitions;");
            mTarget.println("};");
        }

        mTarget.println();
        mTarget.println("/*");
        mTarget.println(" * Local variables:");
        mTarget.println(" *  buffer-read-only: t");
        mTarget.println(" * End:");
        mTarget.println(" */");

        return;
    } // end of visit(SmcFSM)

    /**
     * Emits JavaScript code for the FSM map.
     * @param map emit JavaScript code for this map.
     */
    @Override
    public void visit(final SmcMap map)
    {
        List<SmcTransition> definedDefaultTransitions;
        SmcState defaultState = map.getDefaultState();
        String context = map.getFSM().getContext();
        String mapName = map.getName();
        List<SmcState> states = map.getStates();

        // Initialize the default transition list to all the
        // default state's transitions.
        if (defaultState != null)
        {
            definedDefaultTransitions =
                defaultState.getTransitions();
        }
        else
        {
            definedDefaultTransitions = new ArrayList<>();
        }

        // Declare the constructor.
        mTarget.println();
        mTarget.print("function ");
        mTarget.print(mapName);
        mTarget.print("_DefaultState");
        mTarget.println(" (name, id) {");
        mTarget.println("    State.call(this, name, id);");
        mTarget.println("}");
        // Inheritance.
        mTarget.print(mapName);
        mTarget.print("_DefaultState.prototype = new ");
        mTarget.print(context);
        mTarget.println("State();");
        mTarget.println();

        mTarget.print("var ");
        mTarget.print(mapName);
        mTarget.println(" = {};");
         // Store an instance.
        mTarget.print(mapName);
        mTarget.print(".DefaultState = new ");
        mTarget.print(mapName);
        mTarget.print("_DefaultState");
        mTarget.print("('");
        mTarget.print(mapName);
        mTarget.print("::DefaultState', ");
        mTarget.print(SmcMap.getNextStateId());
        mTarget.println(");");


        // Declare the user-defined default transitions first.
        mIndent = "";
        for (SmcTransition trans: definedDefaultTransitions)
        {
            trans.accept(this);
        }

        // If -reflect was specified, then generate the
        // _transitions map.
        if (mReflectFlag)
        {
            List<SmcTransition> allTransitions =
                map.getFSM().getTransitions();
            String transName;
            String transDefinition;
            String separator = "";

            // Now output the transition collection's
            // initialization.
            mTarget.println();
            mTarget.print(mapName);
            mTarget.println(".DefaultState.transitions = {");

            // Now place all transition names and states into the
            // map.
            for (SmcTransition transition: allTransitions)
            {
                transName = transition.getName();

                // If the transition is defined in this map's
                // default state, then the value is 2.
                if (definedDefaultTransitions.contains(transition))
                {
                    transDefinition = "2";
                }
                // Otherwise the value is 0 - undefined.
                else
                {
                    transDefinition = "0";
                }

                mTarget.print(separator);
                mTarget.print("    '");
                mTarget.print(transName);
                mTarget.print("': ");
                mTarget.print(transDefinition);

                separator = ",\n";
            }
            mTarget.println();
            mTarget.println("};");
        }

        for (SmcState state: states)
        {
            state.accept(this);
        }

        return;
    } // end of visit(SmcMap)

    /**
     * Emits JavaScript code for this FSM state.
     * @param state emits JavaScript code for this state.
     */
    @Override
    public void visit(final SmcState state)
    {
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        List<SmcAction> actions;

        // Declare the constructor.
        mTarget.println();
        mTarget.print("function ");
        mTarget.print(mapName);
        mTarget.print('_');
        mTarget.print(stateName);
        mTarget.println(" (name, id) {");
        mTarget.println("    State.call(this, name, id);");
        mTarget.println("}");
        // Inheritance.
        mTarget.print(mapName);
        mTarget.print('_');
        mTarget.print(stateName);
        mTarget.print(".prototype = ");
        mTarget.print(mapName);
        mTarget.println(".DefaultState;");
        mTarget.println();

        // Store an instance.
        mTarget.print(mapName);
        mTarget.print('.');
        mTarget.print(stateName);
        mTarget.print(" = new ");
        mTarget.print(mapName);
        mTarget.print('_');
        mTarget.print(stateName);
        mTarget.print("('");
        mTarget.print(mapName);
        mTarget.print("::");
        mTarget.print(stateName);
        mTarget.print("', ");
        mTarget.print(SmcMap.getNextStateId());
        mTarget.println(");");

        // Add the entry() and exit() member functions if this
        // state defines them.
        actions = state.getEntryActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.println();
            mTarget.print(mapName);
            mTarget.print('.');
            mTarget.print(stateName);
            mTarget.println(".Entry = function (fsm) {");
            mTarget.println("    var ctxt = fsm.owner;");

            // Generate the actions associated with this code.
            mIndent = "    ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }

            mTarget.println("};");
        }

        actions = state.getExitActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.println();
            mTarget.print(mapName);
            mTarget.print('.');
            mTarget.print(stateName);
            mTarget.println(".Exit = function (fsm) {");
            mTarget.println("    var ctxt = fsm.owner;");

            // Generate the actions associated with this code.
            mIndent = "    ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }

            mTarget.println("};");
        }

        // Have each transition generate its code.
        mIndent = "";
        for (SmcTransition transition: state.getTransitions())
        {
            transition.accept(this);
        }

        // If -reflect was specified, then generate the
        // _transitions map.
        if (mReflectFlag)
        {
            List<SmcTransition> allTransitions =
                map.getFSM().getTransitions();
            List<SmcTransition> stateTransitions =
                state.getTransitions();
            SmcState defaultState = map.getDefaultState();
            List<SmcTransition> defaultTransitions;
            String transName;
            String transDefinition;
            String separator = "";

            // Initialize the default transition list to all the
            // default state's transitions.
            if (defaultState != null)
            {
                defaultTransitions =
                    defaultState.getTransitions();
            }
            else
            {
                defaultTransitions = new ArrayList<>();
            }

            // Now output the transition collection's
            // initialization.
            mTarget.println();
            mTarget.print(mapName);
            mTarget.print('.');
            mTarget.print(stateName);
            mTarget.println(".transitions = {");

            // Now place all transition names and states into the
            // map.
            for (SmcTransition transition: allTransitions)
            {
                transName = transition.getName();

                // If the transition is in this state, then its
                // value is 1.
                if (stateTransitions.contains(transition))
                {
                    transDefinition = "1";
                }
                // If the transition is defined in this map's
                // default state, then the value is 2.
                else if (defaultTransitions.contains(transition))
                {
                    transDefinition = "2";
                }
                // Otherwise the value is 0 - undefined.
                else
                {
                    transDefinition = "0";
                }

                mTarget.print(separator);
                mTarget.print("    '");
                mTarget.print(transName);
                mTarget.print("': ");
                mTarget.print(transDefinition);

                separator = ",\n";
            }
            mTarget.println();

            mTarget.println("};");
        }

        return;
    } // end of visit(SmcState)

    /**
     * Emits JavaScript code for this FSM state transition.
     * @param transition emits JavaScript code for this state transition.
     */
    @Override
    public void visit(final SmcTransition transition)
    {
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String instanceName = state.getInstanceName();
        String transName = transition.getName();
        List<SmcParameter> parameters =
            transition.getParameters();
        List<SmcGuard> guards = transition.getGuards();
        SmcGuard nullGuard = null;
        Iterator<SmcGuard> git = guards.iterator();
        SmcGuard guard;

        mTarget.println();
        mTarget.print(mapName);
        mTarget.print('.');
        mTarget.print(instanceName);
        mTarget.print('.');
        mTarget.print(transName);
        mTarget.print(" = function (fsm");

        // Add user-defined parameters.
        for (SmcParameter parameter: parameters)
        {
            mTarget.print(", ");
            parameter.accept(this);
        }
        mTarget.println(") {");

        // All transitions have a "ctxt" local variable.
        // 8/14/2003:
        // Do this only if there are any transition actions or
        // guard conditions which reference it.
        if (transition.hasCtxtReference())
        {
            mTarget.println("    var ctxt = fsm.owner;");
        }

        // Output state exit.
        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            mTarget.println("    if (fsm.debugFlag) {");
            mTarget.print("        fsm.debugStream.write(\"LEAVING STATE   : ");
            mTarget.print(mapName);
            mTarget.print('.');
            mTarget.print(stateName);
            mTarget.println("\\n\");");
            mTarget.println("    }");
        }

        // Loop through the guards and print each one.
        mGuardIndex = 0;
        mGuardCount = guards.size();
        while (git.hasNext())
        {
            guard = git.next();

            // Output the no condition guard *after* all other
            // guarded transitions.
            if ((guard.getCondition()).isEmpty())
            {
                nullGuard = guard;
            }
            else
            {
                guard.accept(this);
                ++mGuardIndex;
            }
        }

        // Is there an explicitly defined unguarded transition?
        if (nullGuard != null)
        {
            // Does this guard have any actions or is this guard
            // *not* an internal loopback transition?
            if (nullGuard.hasActions() ||
                !(nullGuard.getEndState()).equals(SmcElement.NIL_STATE) ||
                nullGuard.getTransType() == TransType.TRANS_PUSH ||
                nullGuard.getTransType() == TransType.TRANS_POP)
            {
                // Need to output either the action and/or the
                // next state, so output the guard.
                nullGuard.accept(this);
            }

            mTarget.println();
        }
        // If all guards have a condition, then create a final
        // "else" clause which passes control to the default
        // transition. Pass all arguments into the default
        // transition.
        else if (mGuardIndex > 0)
        {
            if (mGuardCount == 1)
            {
                mTarget.print(mIndent);
                mTarget.println("    }");
            }

            mTarget.println("    else {");

            // Call the super class' transition method
            mTarget.print(mIndent);
            mTarget.print("        ");
            mTarget.print(mapName);
            mTarget.print(".DefaultState.");
            if (instanceName.equals("DefaultState") == false)
            {
                mTarget.print(transName);
                mTarget.print("(fsm");

                // Add user-defined parameters.
                for (SmcParameter param: parameters)
                {
                    mTarget.print(", ");
                    mTarget.print(param.getName());
                }
            }
            else
            {
                mTarget.print("Default(fsm");
            }
            mTarget.println(");");
            mTarget.println("    }");
        }
        // Need to add a final newline after a multiguard block.
        else if (mGuardCount > 1)
        {
            mTarget.println();
        }

        mTarget.println("};");

        return;
    } // end of visit(SmcTransition)

    /**
     * Emits JavaScript code for this FSM transition guard.
     * @param guard emits JavaScript code for this transition guard.
     */
    @Override
    public void visit(final SmcGuard guard)
    {
        SmcTransition transition = guard.getTransition();
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String transName = transition.getName();
        TransType transType = guard.getTransType();
        boolean loopbackFlag;
        String indent2;
        String indent3;
        String indent4;
        String endStateName = guard.getEndState();
        String fqEndStateName;
        String pushStateName = guard.getPushState();
        String condition = guard.getCondition();
        List<SmcAction> actions = guard.getActions();
        boolean hasActions = !(actions.isEmpty());

        // If this guard's end state is not of the form
        // "map::state", then prepend the map name to the
        // state name.
        // DON'T DO THIS IF THIS IS A POP TRANSITION!
        // The "state" is actually a transition name.
        if (transType != TransType.TRANS_POP &&
            endStateName.length () > 0 &&
            endStateName.equals(SmcElement.NIL_STATE) == false)
        {
            endStateName = scopeStateName(endStateName, mapName);
        }

        // Qualify the state and push state names as well.
        stateName = scopeStateName(stateName, mapName);
        pushStateName = scopeStateName(pushStateName, mapName);

        loopbackFlag = isLoopback(transType, endStateName);

        // The guard code generation is a bit tricky. The first
        // question is how many guards are there? If there are
        // more than one, then we will need to generate the
        // proper "if-then-else" code.
        if (mGuardCount > 1)
        {
            indent2 = mIndent + "        ";

            // There are multiple guards.
            // Is this the first guard?
            if (mGuardIndex == 0 && condition.length() > 0)
            {
                // Yes, this is the first. This means an "if"
                // should be used.
                mTarget.print(mIndent);
                mTarget.print("    if (");
                mTarget.print(condition);
                mTarget.println(") {");
            }
            else if (condition.length() > 0)
            {
                // No, this is not the first transition but it
                // does have a condition. Use an "else if".
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.print("    else if (");
                mTarget.print(condition);
                mTarget.println(") {");
            }
            else
            {
                // This is not the first transition and it has
                // no condition.
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.println("    else {");
            }
        }
        // There is only one guard. Does this guard have a
        // condition?
        else if (condition.length() == 0)
        {
            // No. This is a plain, old. vanilla transition.
            indent2 = mIndent + "    ";
        }
        else
        {
            // Yes there is a condition.
            indent2 = mIndent + "        ";

            mTarget.print(mIndent);
            mTarget.print("    if (");
            mTarget.print(condition);
            mTarget.println(") {");
        }

        // Now that the necessary conditions are in place, it's
        // time to dump out the transition's actions. First, do
        // the proper handling of the state change. If this
        // transition has no actions, then set the end state
        // immediately. Otherwise, unset the current state so
        // that if an action tries to issue a transition, it will
        // fail.
        if (hasActions == false || loopbackFlag == false)
        {
            fqEndStateName = endStateName;
        }
        // Save away the current state if this is a loopback
        // transition. Storing current state allows the
        // current state to be cleared before any actions are
        // executed. Remember: actions are not allowed to
        // issue transitions and clearing the current state
        // prevents them from doing do.
        else
        {
            fqEndStateName = "endState";

            mTarget.print(indent2);
            mTarget.print("var ");
            mTarget.print(fqEndStateName);
            mTarget.println(" = fsm.getState();");
        }

        // mTarget.println();

        // Dump out the exit actions - but only for the first
        // guard.
        // v. 1.0, beta 3: Not any more. The exit actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a pop transition.
        if (transType == TransType.TRANS_POP ||
            loopbackFlag == false)
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println("if (fsm.debugFlag) {");
                mTarget.print(indent2);
                mTarget.print("    fsm.debugStream.write(\"BEFORE EXIT     : ");
                mTarget.print(stateName);
                mTarget.println(".exit()\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }

            mTarget.print(indent2);
            mTarget.println("fsm.getState().Exit(fsm);");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println("if (fsm.debugFlag) {");
                mTarget.print(indent2);
                mTarget.print("    fsm.debugStream.write(\"AFTER EXIT      : ");
                mTarget.print(stateName);
                mTarget.println(".exit()\\n\");");
                mTarget.print(indent2);
                mTarget.println("    }");
            }

        }

        // Output transition to debug stream.
        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            List<SmcParameter> parameters =
                transition.getParameters();
            Iterator<SmcParameter> pit;
            String sep;

            indent4 = mIndent;
            if (mNoCatchFlag == false)
            {
                mIndent = indent2;
            }

            mTarget.print(mIndent);
            mTarget.println("if (fsm.debugFlag) {");
            mTarget.print(mIndent);
            mTarget.print("    fsm.debugStream.write(\"ENTER TRANSITION: ");
            mTarget.print(stateName);
            mTarget.print('.');
            mTarget.print(transName);

            mTarget.print('(');
            for (pit = parameters.iterator(), sep = "";
                 pit.hasNext();
                 sep = ", ")
            {
                mTarget.print(sep);
                (pit.next()).accept(this);
            }
            mTarget.print(')');

            mTarget.println("\\n\");");
            mTarget.print(mIndent);
            mTarget.println("}");

            mIndent = indent4;
        }

        // Dump out this transition's actions.
        if (hasActions == false)
        {
            if (condition.length() > 0)
            {
                mTarget.print(indent2);
                mTarget.println("// No actions.");
            }

            indent3 = indent2;
        }
        else
        {
            // Now that we are in the transition, clear the
            // current state.
            mTarget.print(indent2);
            mTarget.println("fsm.clearState();");

            // v. 2.0.0: Place the actions inside a try/finally
            // block. This way the state will be set before an
            // exception leaves the transition method.
            // v. 2.2.0: Check if the user has turned off this
            // feature first.
            if (mNoCatchFlag == false)
            {
                mTarget.print(indent2);
                mTarget.println("try {");

                indent3 = indent2 + "    ";
            }
            else
            {
                indent3 = indent2;
            }

            indent4 = mIndent;
            mIndent = indent3;

            for (SmcAction action: actions)
            {
                action.accept(this);
            }

            mIndent = indent4;

            // v. 2.2.0: Check if the user has turned off this
            // feature first.
            if (mNoCatchFlag == false)
            {
                mTarget.print(indent2);
                mTarget.println('}');
                mTarget.print(indent2);
                mTarget.println("finally {");
            }
        }

        // Output transition to debug stream.
        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            List<SmcParameter> parameters =
                transition.getParameters();
            Iterator<SmcParameter> pit;
            String sep;

            indent4 = mIndent;
            mIndent = indent3;

            mTarget.print(mIndent);
            mTarget.println("if (fsm.debugFlag) {");
            mTarget.print(mIndent);
            mTarget.print("    fsm.debugStream.write(\"EXIT TRANSITION : ");
            mTarget.print(stateName);
            mTarget.print('.');
            mTarget.print(transName);

            mTarget.print('(');
            for (pit = parameters.iterator(), sep = "";
                 pit.hasNext();
                 sep = ", ")
            {
                mTarget.print(sep);
                (pit.next()).accept(this);
            }
            mTarget.print(')');

            mTarget.println("\\n\");");
            mTarget.print(mIndent);
            mTarget.println("}");

            mIndent = indent4;
        }

        // Print the setState() call, if necessary. Do NOT
        // generate the set state it:
        // 1. The transition has no actions AND is a loopback OR
        // 2. This is a push or pop transition.
        if (transType == TransType.TRANS_SET &&
            (hasActions || loopbackFlag == false))
        {
            mTarget.print(indent3);
            mTarget.print("fsm.setState(");
            mTarget.print(fqEndStateName);
            mTarget.println(");");
        }
        else if (transType == TransType.TRANS_PUSH)
        {
            // Set the next state so this it can be pushed
            // onto the state stack. But only do so if a clear
            // state was done.
            if (loopbackFlag == false || hasActions)
            {
                mTarget.print(indent3);
                mTarget.print("fsm.setState(");
                mTarget.print(fqEndStateName);
                mTarget.println(");");
            }

            // Before doing the push, execute the end state's
            // entry actions (if any) if this is not a loopback.
            if (loopbackFlag == false)
            {
                mTarget.print(indent3);
                mTarget.println("fsm.getState().Entry(fsm);");
            }

            mTarget.print(indent3);
            mTarget.print("fsm.pushState(");
            mTarget.print(pushStateName);
            mTarget.println(");");
        }
        else if (transType == TransType.TRANS_POP)
        {
            mTarget.print(indent3);
            mTarget.println("fsm.popState();");
        }

        // Perform the new state's enty actions.
        // v. 1.0, beta 3: Not any more. The entry actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a push transition.
        if ((transType == TransType.TRANS_SET &&
             loopbackFlag == false) ||
             transType == TransType.TRANS_PUSH)
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent3);
                mTarget.println("if (fsm.debugFlag) {");
                mTarget.print(indent3);
                mTarget.print("    fsm.debugStream.write(\"BEFORE ENTRY    : ");
                mTarget.print(fqEndStateName);
                mTarget.println(".Entry()\\n\");");
                mTarget.print(indent3);
                mTarget.println("}");
            }

            mTarget.print(indent3);
            mTarget.println("fsm.getState().Entry(fsm);");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent3);
                mTarget.println("if (fsm.debugFlag) {");
                mTarget.print(indent3);
                mTarget.print("    fsm.debugStream.write(\"AFTER ENTRY     : ");
                mTarget.print(fqEndStateName);
                mTarget.println(".Entry()\\n\");");
                mTarget.print(indent3);
                mTarget.println("}");
            }
        }

        // If there was a try/finally, then put the closing
        // brace on the finally block.
        // v. 2.2.0: Check if the user has turned off this
        // feature first.
        if (hasActions && mNoCatchFlag == false)
        {
            mTarget.print(indent2);
            mTarget.println('}');
        }

        // If there is a transition associated with the pop, then
        // issue that transition here.
        if (transType == TransType.TRANS_POP &&
            endStateName.equals(SmcElement.NIL_STATE) == false &&
            endStateName.length() > 0)
        {
            String popArgs = guard.getPopArgs();

            mTarget.println();
            mTarget.print(indent2);
            mTarget.print("fsm.");
            mTarget.print(endStateName);
            mTarget.print("(");

            // Output any and all pop arguments.
            if (popArgs.length() > 0)
            {
                mTarget.print(popArgs);
            }
            mTarget.println(");");
        }

        // If this is a guarded transition, it will be necessary
        // to close off the "if" body. DON'T PRINT A NEW LINE!
        // Why? Because an "else" or "else if" may follow and we
        // won't know until we go back to the transition target
        // generator whether all clauses have been done.
        if (mGuardCount > 1)
        {
            mTarget.print(mIndent);
            mTarget.print("    }");
        }

        return;
    } // end of visit(SmcGuard)

    /**
     * Emits JavaScript code for this FSM action.
     * @param action emits JavaScript code for this action.
     */
    @Override
    public void visit(final SmcAction action)
    {
        String name = action.getName();
        List<String> arguments = action.getArguments();

        if (action.isProperty())
        {
            mTarget.print(mIndent);
            mTarget.print("ctxt.");
            mTarget.print(name);
            mTarget.print(" = ");
            mTarget.print(arguments.get(0));
            mTarget.println(';');
        }
        else
        {
            // Need to distinguish between FSMContext actions and
            // application class actions. If the action is
            // "emptyStateStack", then pass it to the context.
            // Otherwise, let the application class handle it.
            mTarget.print(mIndent);
            if (action.isEmptyStateStack())
            {
                mTarget.println("fsm.emptyStateStack();");
            }
            else
            {
                Iterator<String> it;
                String sep;

                mTarget.print("ctxt.");
                mTarget.print(name);
                mTarget.print("(");

                for (it = arguments.iterator(), sep = "";
                     it.hasNext();
                     sep = ", ")
                {
                    mTarget.print(sep);
                    mTarget.print(it.next());
                }

                mTarget.println(");");
            }
        }

        return;
    } // end of visit(SmcAction)

    /**
     * Emits JavaScript code for this transition parameter.
     * @param parameter emits JavaScript code for this transition
     * parameter.
     */
    @Override
    public void visit(final SmcParameter parameter)
    {
        mTarget.print(parameter.getName());

        return;
    } // end of visit(SmcParameter)

    //
    // end of SmcVisitor Abstract Method Impelementation.
    //-----------------------------------------------------------
} // end of class SmcJSGenerator


//
// CHANGE LOG
// $Log: SmcJSGenerator.java,v $
// Revision 1.5  2013/12/15 16:32:06  fperrad
// full refactor of JavaScript
//
// Revision 1.4  2013/07/14 14:32:38  cwrapp
// check in for release 6.2.0
//
// Revision 1.3  2011/02/16 18:02:01  nitin-nizhawan
// added prototype channing to allow instanceof operator to work
//
// Revision 1.2  2011/02/14 21:29:56  nitin-nizhawan
// corrected some build errors
//
// Revision 1.1  2011/02/14 18:32:04  nitin-nizhawan
// added generator class for JavaScript
//
//
