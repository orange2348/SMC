//
// The contents of this file are subject to the Mozilla Public
// License Version 1.1 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy
// of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an
// "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//
// The Original Code is State Machine Compiler (SMC).
//
// The Initial Developer of the Original Code is Charles W. Rapp.
// Portions created by Charles W. Rapp are
// Copyright (C) 2005 - 2009, 2019. Charles W. Rapp.
// All Rights Reserved.
//
// Port to Python by Francois Perrad, francois.perrad@gadz.org
// Copyright 2004, Francois Perrad.
// All Rights Reserved.
//
// Contributor(s):
//   Eitan Suez contributed examples/Ant.
//   (Name withheld) contributed the C# code generation and
//   examples/C#.
//   Francois Perrad contributed the Python code generation and
//   examples/Python.
//   Chris Liscio contributed the Objective-C code generation
//   and examples/ObjC.
//   Toni Arnold contributed the PHP code generation and
//   examples/Php.
//
//  PHP note:
// "Exit" and "Default" are PHP keywords, so for code generation,
// "Exit_" and "Default_" is used instead - but the .sm input file
// still should use "Default" for default transitions.
//
// RCS ID
// $Id: SmcPhpGenerator.java,v 1.14 2015/08/02 19:44:36 cwrapp Exp $
//
// CHANGE LOG
// (See the bottom of this file.)
//

package net.sf.smc.generator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcFSM;
import net.sf.smc.model.SmcGuard;
import net.sf.smc.model.SmcMap;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.SmcState;
import net.sf.smc.model.SmcTransition;
import net.sf.smc.model.SmcVisitor;
import net.sf.smc.model.TargetLanguage;

/**
 * Visits the abstract syntax tree, emitting Python code.
 * @see SmcElement
 * @see SmcCodeGenerator
 * @see SmcVisitor
 * @see SmcOptions
 *
 * @author Toni Arnold
 */

public final class SmcPhpGenerator
    extends SmcCodeGenerator
{
//---------------------------------------------------------------
// Member data
//

//---------------------------------------------------------------
// Member methods
//

    //-----------------------------------------------------------
    // Constructors.
    //

    /**
     * Creates a PHP code generator for the given options.
     * @param options command line options.
     */
    public SmcPhpGenerator(final SmcOptions options)
    {
        super (options, TargetLanguage.PHP.suffix());
    } // end of SmcPhpGenerator(SmcOptions)

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // SmcVisitor Abstract Method Impelementation.
    //

    /**
     * Emits PHP code for the finite state machine.
     * @param fsm emit PHP code for this finite state machine.
     */
    @Override
    public void visit(final SmcFSM fsm)
    {
        String context = fsm.getContext();
        String rawSource = fsm.getSource();
        String startState = fsm.getStartState();
        String phpState;
        List<SmcMap> maps = fsm.getMaps();
        List<SmcTransition> transitions;
        List<SmcParameter> params;
        Iterator<SmcParameter> pit;
        String transName;
        String separator;

        mTarget.println("<?php");
        mTarget.println("/*");
        mTarget.println(" ex: set ro:");
        mTarget.println(" DO NOT EDIT.");
        mTarget.println(
            " generated by smc (http://smc.sourceforge.net/)");
        mTarget.print(" from file : ");
        mTarget.print(mSrcfileBase);
        mTarget.println(".sm");
        mTarget.println("*/");
        mTarget.println();

        // Dump out the raw target code, if any.
        if (rawSource != null && rawSource.length () > 0)
        {
            mTarget.println(rawSource);
            mTarget.println();
        }

        mTarget.println("require_once 'StateMachine/statemap.php';");
        mTarget.println();

        // Do user-specified imports now.
        for (String imp: fsm.getImports())
        {
            mTarget.print("require_once '");
            mTarget.print(imp);
            mTarget.println("';");
        }

        // Declare the state class.
        mTarget.println();
        mTarget.print("class ");
        mTarget.print(context);
        mTarget.println("State extends State {");

        mTarget.println();
        mTarget.println("    public function Entry($fsm) {");
        mTarget.println("    }");
        mTarget.println();
        mTarget.println("    public function Exit_($fsm) {");
        mTarget.println("    }");
        mTarget.println();

        // Get the transition list.
        // Generate the default transition definitions.
        transitions = fsm.getTransitions();
        for (SmcTransition trans: transitions)
        {
            params = trans.getParameters();

            // Don't generate the Default transition here.
            if (trans.getName().equals("Default") == false)
            {
                mTarget.print("    public function ");
                mTarget.print(trans.getName());
                mTarget.print("($fsm");

                for (SmcParameter param: params)
                {
                    mTarget.print(", ");
                    param.accept(this);
                }

                mTarget.println(") {");

                // If this method is reached, that means that
                // this transition was passed to a state which
                // does not define the transition. Call the
                // state's default transition method.
                mTarget.println("        $this->Default_($fsm);");
                mTarget.println("    }");
                mTarget.println();
            }
        }

        // Generate the overall Default transition for all maps.
        mTarget.println("    public function Default_($fsm) {");

        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            mTarget.println(
                "        if ($fsm->getDebugFlag() == true) {");
            mTarget.println(
                "            fwrite($fsm->getDebugStream(), \"TRANSITION   : Default\\n\");");
            mTarget.println(
                "        }");
        }

        mTarget.println(
            "        $state = $fsm->getState()->getName();");
        mTarget.println(
            "        $transition = $fsm->getTransition();");
        mTarget.println(
            "        $msg = \"\\n\\tState: $state\\n\\tTransition: $transition\";");
        mTarget.println(
            "        throw new TransitionUndefinedException($msg);");
        mTarget.println("    }");

        mTarget.println("}");   // end of state class

        // Have each map print out its target code now.
        for (SmcMap map: maps)
        {
            map.accept(this);
        }

        // The context class contains all the state classes as
        // inner classes, so generate the context first rather
        // than last.
        mTarget.println();
        mTarget.print("class ");
        mTarget.print(context);
        mTarget.println("_sm extends FSMContext {");
        mTarget.println();

        phpState = phpStateName(startState);

        // Generate the context class' constructor.
        mTarget.println("    public function __construct($owner) {");
        mTarget.print("        parent::__construct(");
        mTarget.print(phpState);
        mTarget.println(");");
        mTarget.println("        $this->_owner = $owner;");

        mTarget.println("    }");
        mTarget.println();

        // Generate the transition methods.
        for (SmcTransition trans: transitions)
        {
            transName = trans.getName();

            if (transName.equals("Default") == false)
            {
                mTarget.print("    public function ");
                mTarget.print(transName);
                mTarget.print("(");

                // Now output the transition's parameters.
                params = trans.getParameters();
                for (pit = params.iterator(), separator = "";
                     pit.hasNext();
                     separator = ", ")
                {
                    mTarget.print(separator);
                    (pit.next()).accept(this);
                }
                mTarget.println(") {");

                // Save away the transition name in case it is
                // need in an UndefinedTransitionException.
                mTarget.print("        $this->_transition = \"");
                mTarget.print(transName);
                mTarget.println("\";");

                mTarget.print("        $this->getState()->");
                mTarget.print(transName);
                mTarget.print("($this");

                for (pit = params.iterator();
                     pit.hasNext();
                    )
                {
                    mTarget.print(", ");
                    mTarget.print((pit.next()).getName());
                }
                mTarget.println(");");
                mTarget.println(
                    "        $this->_transition = NULL;");

                mTarget.println("    }");
                mTarget.println();
            }
        }

        // getState() method.
        mTarget.println("    public function getState() {");
        mTarget.println("        if ($this->_state == NULL) {");
        mTarget.println(
            "            throw new StateUndefinedException();");
        mTarget.println("        }");
        mTarget.println("        return $this->_state;");
        mTarget.println("    }");
        mTarget.println();

        // enterStartState()
        // Execute the start state's entry actions.
        mTarget.println("    public function enterStartState() {");
        mTarget.println("        $this->_state->Entry($this);");
        mTarget.println("    }");
        mTarget.println();

        // getOwner() method.
        mTarget.println("    public function getOwner() {");
        mTarget.println("        return $this->_owner;");
        mTarget.println("    }");
        mTarget.println();

        if (mReflectFlag)
        {
            // getStates() method.
            mTarget.println("    public function getStates() {");
            mTarget.println("        return array(");
            for (SmcMap map: maps)
            {
                String mapName = map.getName();

                mTarget.print("            ");
                mTarget.print(mapName);
                mTarget.println("::$Default_,");

                for (SmcState state: map.getStates())
                {
                    mTarget.print("            ");
                    mTarget.print(mapName);
                    mTarget.print("::$");
                    mTarget.print(state.getClassName());
                    mTarget.println(",");
                }
            }
            mTarget.println("        );");
            mTarget.println("    }");
            mTarget.println();

            // getTransitions() method.
            mTarget.println("    public function getTransitions() {");
            mTarget.println("        return array(");
            for (SmcTransition trans: transitions)
            {
                mTarget.print("            '");
                mTarget.print(trans.getName());
                mTarget.println("',");
            }
            mTarget.println("        );");
            mTarget.println("    }");
            mTarget.println();
        }

        mTarget.println("}");      // end of context class
        mTarget.println();

        mTarget.println("/*");
        mTarget.println(" Local variables:");
        mTarget.println("  buffer-read-only: t");
        mTarget.println(" End:");
        mTarget.println("*/");
        mTarget.println("?>");

        return;
    } // end of visit(SmcFSM)

    /**
     * Emits PHP code for the FSM map.
     * @param map emit PHP code for this map.
     */
    @Override
    public void visit(final SmcMap map)
    {
        List<SmcTransition> definedDefaultTransitions;
        SmcState defaultState = map.getDefaultState();
        String context = map.getFSM().getContext();
        String mapName = map.getName();
        List<SmcState> states = map.getStates();

        // Initialize the default transition list to all the
        // default state's transitions.
        if (defaultState != null)
        {
            definedDefaultTransitions =
                    defaultState.getTransitions();
        }
        else
        {
            definedDefaultTransitions = new ArrayList<>();
        }

        // Declare the map default state class.
        mTarget.println();
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.print("_Default extends ");
        mTarget.print(context);
        mTarget.println("State {");

        // Declare the user-defined default transitions first.
        for (SmcTransition transition: definedDefaultTransitions)
        {
            transition.accept(this);
        }

        // If -reflect was specified, then generate the
        // _transitions table.
        if (mReflectFlag)
        {
            List<SmcTransition> allTransitions =
                map.getFSM().getTransitions();
            String transName;
            int transDefinition;

            // Generate the getTransitions() method.
            mTarget.println();
            mTarget.println("    public function getTransitions() {");
            mTarget.println("        return array(");

            // Now place all transition names and states into the
            // map.
            for (SmcTransition transition: allTransitions)
            {
                transName = transition.getName();

                // If the transition is defined in this map's
                // default state, then the value is 2.
                if (definedDefaultTransitions.contains(transition))
                {
                    transDefinition = 2;
                }
                // Otherwise the value is 0 - undefined.
                else
                {
                    transDefinition = 0;
                }

                mTarget.print("            '");
                mTarget.print(transName);
                mTarget.print("' => ");
                mTarget.print(transDefinition);
                mTarget.println(",");
            }
            mTarget.println("        );");
            mTarget.println("    }");
        }

        mTarget.println();
        mTarget.println("}");   // end of default state class


        // Have each state now generate its code.
        for (SmcState state: states)
        {
            state.accept(this);
        }

        // Declare and initialize the map class.
        // In PHP, static objects need to be instantiated
        // outside of the class, see
        // http://ch2.php.net/manual/en/language.oop5.static.php#51627
        mTarget.println();
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.println(" {");

        // declare the static members
        for (SmcState state: states)
        {
            mTarget.print("    public static $");
            mTarget.print(state.getInstanceName());
            mTarget.println(";");
        }
        mTarget.println("    public static $Default_;");
        mTarget.println("}");

        // after the class declaration, instantiate the static members
        for (SmcState state: states)
        {
            mTarget.print(mapName);
            mTarget.print("::$");
            mTarget.print(state.getInstanceName());
            mTarget.print(" = new ");
            mTarget.print(mapName);
            mTarget.print('_');
            mTarget.print(state.getClassName());
            mTarget.print("('");
            mTarget.print(mapName);
            mTarget.print('.');
            mTarget.print(state.getClassName());
            mTarget.print("', ");
            mTarget.print(SmcMap.getNextStateId());
            mTarget.println(");");
        }

        // Instantiate a default state as well.
        mTarget.print(mapName);
        mTarget.print("::$Default_");
        mTarget.print(" = new ");
        mTarget.print(mapName);
        mTarget.print("_Default('");
        mTarget.print(mapName);
        mTarget.println(".Default_', -1);");

        return;
    } // end of visit(SmcMap)

    /**
     * Emits PHP code for this FSM state.
     * @param state emits PHP code for this state.
     */
    @Override
    public void visit(final SmcState state)
    {
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        List<SmcAction> actions;
        String indent2;

        // Declare the state class.
        mTarget.println();
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.print('_');
        mTarget.print(stateName);
        mTarget.print(" extends ");
        mTarget.print(mapName);
        mTarget.println("_Default {");

        // Add the Entry() and Exit_() member functions if this
        // state defines them.
        actions = state.getEntryActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.println();
            mTarget.println("    public function Entry($fsm) {");

            // Declare the "ctxt" local variable.
            mTarget.println("        $ctxt = $fsm->getOwner();");

            // Generate the actions associated with this code.
            indent2 = mIndent;
            mIndent = "        ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            mIndent = indent2;

            mTarget.println("    }");
        }

        actions = state.getExitActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.println();
            mTarget.println("    public function Exit_($fsm) {");

            // Declare the "ctxt" local variable.
            mTarget.println("        $ctxt = $fsm->getOwner();");

            // Generate the actions associated with this code.
            indent2 = mIndent;
            mIndent = "        ";
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            mIndent = indent2;

            mTarget.println("    }");
        }

        // Have each transition generate its code.
        for (SmcTransition transition: state.getTransitions())
        {
            transition.accept(this);
        }

        // If -reflect was specified, then generate the
        // _transitions table.
        if (mReflectFlag)
        {
            List<SmcTransition> allTransitions =
                map.getFSM().getTransitions();
            List<SmcTransition> stateTransitions =
                state.getTransitions();
            SmcState defaultState = map.getDefaultState();
            List<SmcTransition> defaultTransitions;
            String transName;
            int transDefinition;

            // Initialize the default transition list to all the
            // default state's transitions.
            if (defaultState != null)
            {
                defaultTransitions =
                    defaultState.getTransitions();
            }
            else
            {
                defaultTransitions = new ArrayList<>();
            }

            // Generate the getTransitions() method.
            mTarget.println();
            mTarget.println("    public function getTransitions() {");
            mTarget.println("        return array(");

            // Now place all transition names and states into the
            // map.
            for (SmcTransition transition: allTransitions)
            {
                transName = transition.getName();

                // If the transition is in this state, then its
                // value is 1.
                if (stateTransitions.contains(transition))
                {
                    transDefinition = 1;
                }
                // If the transition is defined in this map's
                // default state, then the value is 2.
                else if (defaultTransitions.contains(transition))
                {
                    transDefinition = 2;
                }
                // Otherwise the value is 0 - undefined.
                else
                {
                    transDefinition = 0;
                }

                mTarget.print("            '");
                mTarget.print(transName);
                mTarget.print("' => ");
                mTarget.print(transDefinition);
                mTarget.println(",");
            }
            mTarget.println("        );");
            mTarget.println("    }");
        }

        mTarget.println();
        mTarget.println("}");

        // End of this state class declaration.

        return;
    } // end of visit(SmcState)

    /**
     * Emits PHP code for this FSM state transition.
     * @param transition emits PHP code for this state transition.
     */
    @Override
    public void visit(final SmcTransition transition)
    {
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String transName = transition.getName();
        List<SmcParameter> parameters =
            transition.getParameters();
        List<SmcGuard> guards = transition.getGuards();
        Iterator<SmcGuard> git = guards.iterator();
        SmcGuard guard;
        SmcGuard nullGuard = null;

        mTarget.println();
        mTarget.print("    public function ");
        mTarget.print(sanitizeKeyword(transName));
        mTarget.print("($fsm");

        // Add user-defined parameters.
        for (SmcParameter param: parameters)
        {
            mTarget.print(", ");
            param.accept(this);
        }
        mTarget.println(") {");

        // All transitions have a "ctxt" local variable.
        // 8/14/2003:
        // Do this only if there are any transition actions or
        // guard conditions which reference it.
        if (transition.hasCtxtReference())
        {
            mTarget.println("        $ctxt = $fsm->getOwner();");
        }

        // Output transition to debug stream.
        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            mTarget.println(
                "        if ($fsm->getDebugFlag() == true) {");
            mTarget.print(
                "            fwrite($fsm->getDebugStream(), ");
            mTarget.print("\"LEAVING STATE   : ");
            mTarget.print(mapName);
            mTarget.print("::\\$");
            mTarget.print(stateName);
            mTarget.println("\\n\");");
            mTarget.println("        }");
        }

        // Loop through the guards and print each one.
        mIndent = "        ";
        mGuardIndex = 0;
        mGuardCount = guards.size();
        while (git.hasNext())
        {
            guard = git.next();

            // Count up the guards with no condition.
            if (guard.getCondition().isEmpty())
            {
                nullGuard = guard;
            }
            else
            {
                guard.accept(this);
                ++mGuardIndex;
            }
        }

        // Is there an explicitly defined unguarded transition?
        if (nullGuard != null)
        {
            // Does this guard have any actions or is this guard
            // *not* an internal loopback transition?
            if (nullGuard.hasActions() ||
                !(nullGuard.getEndState()).equals(SmcElement.NIL_STATE) ||
                nullGuard.getTransType() == TransType.TRANS_PUSH ||
                nullGuard.getTransType() == TransType.TRANS_POP)
            {
                // Need to output either the action and/or the
                // next state, so output the guard.
                nullGuard.accept(this);
            }

            mTarget.println();
        }
        // If all guards have a condition, then create a final
        // "else" clause which passes control to the default
        // transition. Pass all arguments into the default
        // transition.
        else if (mGuardIndex > 0)
        {
            if (mGuardCount == 1)
            {
                mTarget.println("        }");
            }

            mTarget.println("        else {");

            // Call the super class' transition method using
            // the "parent" keyword and not the class name.
            mTarget.print("            ");
            mTarget.print("parent::");
            mTarget.print(transName);
            mTarget.print("($fsm");

            for (SmcParameter param: parameters)
            {
                mTarget.print(", ");
                mTarget.print(param.getName());
            }

            mTarget.println(");");
            mTarget.println("        }");
        }
        // Need to add a final newline after a multiguard block.
        else if (mGuardCount > 1)
        {
            mTarget.println();
        }

        mTarget.println("    }");

        return;
    } // end of visit(SmcTransition)

    /**
     * Emits PHP code for this FSM transition guard.
     * @param guard emits PHP code for this transition guard.
     */
    @Override
    public void visit(final SmcGuard guard)
    {
        SmcTransition transition = guard.getTransition();
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String transName = transition.getName();
        TransType transType = guard.getTransType();
        boolean loopbackFlag;
        String indent2;
        String indent3;
        String indent4;
        String endStateName = guard.getEndState();
        String fqEndStateName = "";
        String pushStateName = guard.getPushState();
        String condition = guard.getCondition();
        List<SmcAction> actions = guard.getActions();

        // If this guard's end state is not of the form
        // "map::state", then prepend the map name to the
        // state name.
        // DON'T DO THIS IF THIS IS A POP TRANSITION!
        // The "state" is actually a transition name.
        if (transType != TransType.TRANS_POP &&
            endStateName.length () > 0 &&
            endStateName.equals(SmcElement.NIL_STATE) == false &&
            !endStateName.contains("::"))
        {
            endStateName = mapName + "::" + endStateName;
        }
        endStateName = phpStateName(endStateName);

        // Qualify the state and push state names as well.
        if (!stateName.contains("::"))
        {
            stateName = mapName + "::" + stateName;
        }
        stateName = phpStateName(stateName);

        // v. 2.0.2: If the push state is not fully-qualified,
        // then prepend the current map's name and make if
        // fully-qualified.
        if (pushStateName != null &&
            pushStateName.length() > 0)
        {
            if (!pushStateName.contains("::"))
            {
                pushStateName = mapName + "::" + pushStateName;
            }
        }
        pushStateName = phpStateName(pushStateName);

        loopbackFlag = isLoopback(transType, endStateName);

        // The guard code generation is a bit tricky. The first
        // question is how many guards are there? If there are
        // more than one, then we will need to generate the
        // proper "if-then-else" code.
        if (mGuardCount > 1)
        {
            indent2 = mIndent + "    ";

            // There are multiple guards. Is this the first
            // guard?
            if (mGuardIndex == 0 && condition.length() > 0)
            {
                // Yes, this is the first. This means an "if"
                // should be used.
                mTarget.print(mIndent);
                mTarget.print("if (");
                mTarget.print(condition);
                mTarget.println(") {");
            }
            else if (condition.length() > 0)
            {
                // No, this is not the first transition but it
                // does have a condition. Use an "else if".
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.print("elseif (");
                mTarget.print(condition);
                mTarget.println(") {");
            }
            else
            {
                // This is not the first transition and it has
                // no condition.
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.println("else {");
            }
        }
        // There is only one guard. Does this guard have
        // a condition?
        else if (condition.length() == 0)
        {
            // No. This is a plain, old. vanilla transition.
            indent2 = mIndent;
        }
        else
        {
            // Yes there is a condition.
            indent2 = mIndent + "    ";

            mTarget.print(mIndent);
            mTarget.print("if (");
            mTarget.print(condition);
            mTarget.println(") {");
        }

        // Now that the necessary conditions are in place, it's
        // time to dump out the transition's actions. First, do
        // the proper handling of the state change. If this
        // transition has no actions, then set the end state
        // immediately. Otherwise, unset the current state so
        // that if an action tries to issue a transition, it will
        // fail.
        if (actions.isEmpty() && endStateName.length() != 0)
        {
            fqEndStateName = endStateName;
        }
        else if (actions.size() > 0)
        {
            // Save away the current state if this is a loopback
            // transition. Storing current state allows the
            // current state to be cleared before any actions are
            // executed. Remember: actions are not allowed to
            // issue transitions and clearing the current state
            // prevents them from doing do.
            if (loopbackFlag)
            {
                fqEndStateName = "$endState";

                mTarget.print(indent2);
                mTarget.print(fqEndStateName);
                mTarget.println(" = $fsm->getState();");
            }
            else
            {
                fqEndStateName = endStateName;
            }
        }

        // Dump out the exit actions - but only for the first
        // guard.
        // v. 1.0, beta 3: Not any more. The exit actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a pop transition.
        if (transType == TransType.TRANS_POP ||
            loopbackFlag == false)
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println(
                    "if ($fsm->getDebugFlag() == true) {");
                mTarget.print(indent2);
                mTarget.print(
                    "    fwrite($fsm->getDebugStream(), \"");
                mTarget.print("BEFORE EXIT     : ");
                mTarget.print(stateName);
                mTarget.println("->Exit_($fsm)\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }

            mTarget.print(indent2);
            mTarget.println("$fsm->getState()->Exit_($fsm);");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println(
                    "if ($fsm->getDebugFlag() == true) {");
                mTarget.print(indent2);
                mTarget.print(
                    "    fwrite($fsm->getDebugStream(), \"");
                mTarget.print("AFTER EXIT      : ");
                mTarget.print(stateName);
                mTarget.println("->Exit_($fsm)\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }
        }

        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            List<SmcParameter> parameters =
                transition.getParameters();
            Iterator<SmcParameter> pit;
            String sep;

            mTarget.print(indent2);
            mTarget.println("if ($fsm->getDebugFlag()) {");
            mTarget.print(indent2);
            mTarget.print(
                "    fwrite($fsm->getDebugStream(), \"");
            mTarget.print("ENTER TRANSITION: ");
            mTarget.print(stateName);
            mTarget.print("->");
            mTarget.print(transName);
            mTarget.print("(");
            for (pit = parameters.iterator(), sep = "";
                 pit.hasNext();
                 sep = ", ")
            {
                mTarget.print(sep);
                (pit.next()).accept(this);
            }
            mTarget.print(");");

            mTarget.println("\\n\");");
            mTarget.print(indent2);
            mTarget.println("}");
        }

        // Dump out this transition's actions.
        if (actions.isEmpty())
        {
            List<SmcAction> entryActions =
                state.getEntryActions();
            List<SmcAction> exitActions = state.getExitActions();

            // If this is an if or else body, then give it a
            // pass.
            if (condition.length() > 0 ||
                mGuardCount > 1)
            {
                mTarget.print(indent2);
                mTarget.println("# No actions.");
            }
            // If there are:
            // 1. No entry actions,
            // 2. No exit actions,
            // 3. Only one guard,
            // 4. No condition,
            // 5. No actions,
            // 6. Not a loopback, push or pop transition and
            // 7. No debug code being generated.
            // then give this transition a pass.
            else if (mGuardCount == 1 &&
                     (entryActions == null ||
                      entryActions.isEmpty()) &&
                     (exitActions == null ||
                      exitActions.isEmpty()) &&
                     transType != TransType.TRANS_PUSH &&
                     transType != TransType.TRANS_POP &&
                     loopbackFlag &&
                     mDebugLevel == NO_DEBUG_OUTPUT)
            {
                mTarget.print(indent2);
                mTarget.println("# No actions.");
                mTarget.print(indent2);
            }
        }
        else
        {
            // Now that we are in the transition, clear the
            // current state.
            mTarget.print(indent2);
            mTarget.println("$fsm->clearState();");

            // v. 2.0.0: Place the actions inside a try/finally
            // block. This way the state will be set before an
            // exception leaves the transition method.
            // v. 2.2.0: Check if the user has turned off this
            // feature first.
            if (mNoCatchFlag == false)
            {
                mTarget.print(indent2);
                mTarget.println("$exception = NULL;");
                mTarget.print(indent2);
                mTarget.println("try {");

                indent3 = indent2 + "    ";
            }
            else
            {
                indent3 = indent2;
            }

            indent4 = mIndent;
            mIndent = indent3;

            for (SmcAction action: actions)
            {
                action.accept(this);
            }

            mIndent = indent4;

            // v. 2.2.0: Check if the user has turned off this
            // feature first.
            // PHP has no 'finally', thus emulate it with catch
            // and rethrow at the end.
            // http://bugs.php.net/bug.php?id=32100
            if (mNoCatchFlag == false)
            {
                mTarget.print(indent2);
                mTarget.println("}");
                mTarget.print(indent2);
                mTarget.println("catch (Exception $exception) {}");
            }
        }

        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            List<SmcParameter> parameters =
                transition.getParameters();
            Iterator<SmcParameter> pit;
            String sep;

            mTarget.print(indent2);
            mTarget.println("if ($fsm->getDebugFlag()) {");
            mTarget.print(indent2);
            mTarget.print(
                "    fwrite($fsm->getDebugStream(), \"");
            mTarget.print("EXIT TRANSITION : ");
            mTarget.print(stateName);
            mTarget.print("->");
            mTarget.print(transName);
            mTarget.print("(");
            for (pit = parameters.iterator(), sep = "";
                 pit.hasNext();
                 sep = ", ")
            {
                mTarget.print(sep);
                (pit.next()).accept(this);
            }
            mTarget.print(");");

            mTarget.println("\\n\");");
            mTarget.print(indent2);
            mTarget.println("}");
        }

        // Print the setState() call, if necessary. Do NOT
        // generate the set state it:
        // 1. The transition has no actions AND is a loopback OR
        // 2. This is a push or pop transition.
        if (transType == TransType.TRANS_SET &&
            (actions.isEmpty() == false ||
             loopbackFlag == false))
        {
            mTarget.print(indent2);
            mTarget.print("$fsm->setState(");
            mTarget.print(fqEndStateName);
            mTarget.println(");");
        }
        else if (transType == TransType.TRANS_PUSH)
        {
            // Set the next state so this it can be pushed
            // onto the state stack. But only do so if a clear
            // state was done.
            if (loopbackFlag == false ||
                actions.isEmpty() == false)
            {
                mTarget.print(indent2);
                mTarget.print("$fsm->setState(");
                mTarget.print(fqEndStateName);
                mTarget.println(");");
            }

            // Before doing the push, execute the end state's
            // entry actions (if any) if this is not a loopback.
            if (loopbackFlag == false)
            {
                if (mDebugLevel >= DEBUG_LEVEL_1)
                {
                    mTarget.print(indent2);
                    mTarget.println(
                        "if ($fsm->getDebugFlag() == true) {");
                    mTarget.print(indent2);
                    mTarget.print(
                        "    fwrite($fsm->getDebugStream(), \"");
                    mTarget.print("BEFORE ENTRY    : ");
                    mTarget.print(fqEndStateName);
                    mTarget.println("->Entry($fsm);\\n\");");
                    mTarget.print(indent2);
                    mTarget.println("}");
                }

                mTarget.print(indent2);
                mTarget.println("$fsm->getState()->Entry($fsm);");

                if (mDebugLevel >= DEBUG_LEVEL_1)
                {
                    mTarget.print(indent2);
                    mTarget.println(
                        "if ($fsm->getDebugFlag() == true) {");
                    mTarget.print(indent2);
                    mTarget.print(
                        "    fwrite($fsm->getDebugStream(), \"");
                    mTarget.print("AFTER ENTRY     : ");
                    mTarget.print(fqEndStateName);
                    mTarget.println("->Entry($fsm);\\n\");");
                    mTarget.print(indent2);
                    mTarget.println("}");
                }
            }

            mTarget.print(indent2);
            mTarget.print("$fsm->pushState(");
            mTarget.print(pushStateName);
            mTarget.println(");");
        }
        else if (transType == TransType.TRANS_POP)
        {
            mTarget.print(indent2);
            mTarget.println("$fsm->popState();");
        }

        // Perform the new state's enty actions.
        // v. 1.0, beta 3: Not any more. The entry actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a push transition.
        if ((transType == TransType.TRANS_SET &&
             loopbackFlag == false) ||
             transType == TransType.TRANS_PUSH)
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println(
                    "if ($fsm->getDebugFlag() == true) {");
                mTarget.print(indent2);
                mTarget.print(
                    "    fwrite($fsm->getDebugStream(), \"");
                mTarget.print("BEFORE ENTRY    : ");
                mTarget.print(fqEndStateName);
                mTarget.println("->Entry($fsm);\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }

            mTarget.print(indent2);
            mTarget.println("$fsm->getState()->Entry($fsm);");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println(
                    "if ($fsm->getDebugFlag() == true) {");
                mTarget.print(indent2);
                mTarget.print(
                    "    fwrite($fsm->getDebugStream(), \"");
                mTarget.print("AFTER ENTRY     : ");
                mTarget.print(fqEndStateName);
                mTarget.println("->Entry($fsm);\\n\");");
                mTarget.print(indent2);
                mTarget.println("}");
            }
        }

        // If there was a try/finally, then put the closing
        // brace on the finally block.
        // v. 2.2.0: Check if the user has turned off this
        // feature first.
        // PHP: rethrow the exception to emulate finally.
        if (actions.size() > 0 && mNoCatchFlag == false)
        {
            mTarget.print(indent2);
            mTarget.println("if ($exception != NULL) {");
            mTarget.print(indent2);
            mTarget.println("    throw $exception;");
            mTarget.print(indent2);
            mTarget.println("}");
        }

        // If there is a transition associated with the pop, then
        // issue that transition here.
        if (transType == TransType.TRANS_POP &&
            endStateName.equals(SmcElement.NIL_STATE) == false &&
            endStateName.length() > 0)
        {
            String popArgs = guard.getPopArgs();

            mTarget.print(indent2);
            mTarget.print("$fsm->");
            mTarget.print(endStateName);
            mTarget.print("(");

            // Output any and all pop arguments.
            if (popArgs.length() > 0)
            {
                mTarget.print(popArgs);
                mTarget.println();
                mTarget.print(indent2);
                mTarget.println(");");
            }
            else
            {
                mTarget.println(");");
            }
        }

        // If this is a guarded transition, it will be necessary
        // to close off the "if" body. DON'T PRINT A NEW LINE!
        // Why? Because an "else" or "else if" may follow and we
        // won't know until we go back to the transition target
        // generator whether all clauses have been done.
        if (mGuardCount > 1)
        {
            mTarget.print(mIndent);
            mTarget.print("}");
        }

        return;
    } // end of visit(SmcGuard)

    /**
     * Emits PHP code for this FSM action.
     * @param action emits PHP code for this action.
     */
    @Override
    public void visit(final SmcAction action)
    {
        String name = action.getName();
        Iterator<String> it;
        String sep;

        // Need to distinguish between FSMContext actions and
        // application class actions. If the action is
        // "emptyStateStack", then pass it to the context.
        // Otherwise, let the application class handle it.
        mTarget.print(mIndent);
        if ( action.isEmptyStateStack())
        {
            mTarget.println("$fsm->emptyStateStack();");
        }
        else
        {
        	if ( action.isStatic( )==false )
        	{
	            mTarget.print("$ctxt->");
        	}
	        mTarget.print(name);
	        mTarget.print("(");

	        for (it = action.getArguments().iterator(), sep = "";
	             it.hasNext();
	             sep = ", ")
	        {
	            mTarget.print(sep);
	            mTarget.print(it.next());
	        }

	        mTarget.println(");");
        }

        return;
    } // end of visit(SmcAction)

    /**
     * Emits PHP code for this transition parameter.
     * @param parameter emits PHP code for this transition
     * parameter.
     */
    @Override
    public void visit(final SmcParameter parameter)
    {
        String type = parameter.getType();

        if (type.equals(""))
        {
            mTarget.print(parameter.getName());
        }
        else
        {
            mTarget.print(type);
            mTarget.print(" ");
            mTarget.print(parameter.getName());
        }

        return;
    } // end of visit(SmcParameter)

    //
    // end of SmcVisitor Abstract Method Impelementation.
    //-----------------------------------------------------------

    // State names like "map::state" must be changed to
    // "map::$state" for accessing static members in PHP.
    private String phpStateName(final String state)
    {
        int index = state.indexOf("::");
        String retval = state;

        if (index >= 0)
        {
            retval =
                state.substring(0, index) +
                "::$" +
                state.substring(index + 2);
        }

        return (retval);
    } // end of phpStateName(String)

    // Sanitize PHP keywords used as transition name
    // by appending a "_".
    // Extend the conditional for other keywords surfacing.
    private String sanitizeKeyword(final String transName)
    {
        String retval = transName;

        if (transName.equalsIgnoreCase("Default") )
        {
            retval = transName + "_";
        }

        return (retval);
    } // end of sanitizeKeywork(String)
} // end of class SmcPhpGenerator

//
// CHANGE LOG
// $Log: SmcPhpGenerator.java,v $
// Revision 1.14  2015/08/02 19:44:36  cwrapp
// Release 6.6.0 commit.
//
// Revision 1.13  2015/02/16 21:43:09  cwrapp
// SMC v. 6.5.0
//
// SMC - The State Machine Compiler v. 6.5.0
//
// Major changes:
//
// (Java)
//     Added a new "-java7" target language. This version represents
//     the FSM as a transition table. The transition table maps the
//     current state and the transition to a
//     java.lang.invoke.MethodHandle. The transition is executed by
//     calling MethodHandle.invokeExact, which is only slightly
//     slower than a compiled method call.
//
//     The -java7 generated code is compatible with -java generated
//     code. This allows developers to switch between the two
//     without changing application code.
//
//     NOTE: -java7 requires Java 1.7 or latter to run.
//
//
// Minor changes:
//
// (None.)
//
//
// Bug Fixes:
//
// (Objective-C)
//     Incorrect initWithOwner body generated. Same fundamental
//     problem as SF bug 200. See below.
//     (SF bug 198)
//
// (Website)
//     Corrected broken link in FAQ page.
//     (SF bug 199)
//
// (C++)
//     Corrected the invalid generated FSM class name.
//     (SF bug 200)
//
// (C)
//     EXIT_STATE() #define macro not generated.
//     (SF bug 201)
//
// (Manual)
//     Corrected examples which showed %fsmclass and %map set to the
//     same name. This is invalid for most target languages since
//     that would mean the nested map class would have the same name
//     as the containing FSM class.
//
//
//
// ++++++++++++++++++++++++++++++++++++++++
//
// If you have any questions or bugs, please surf
// over to http://smc.sourceforge.net and check out
// the discussion and bug forums. Note: you must be
// a SourceForge member to add articles or bugs. You
// do not have to be a member to read posted
// articles or bugs.
//
// Revision 1.12  2013/07/14 14:32:38  cwrapp
// check in for release 6.2.0
//
// Revision 1.11  2011/11/20 14:58:33  cwrapp
// Check in for SMC v. 6.1.0
//
// Revision 1.10  2010/03/15 13:15:03  fperrad
// fix multi guard
//
// Revision 1.9  2009/12/17 19:51:43  cwrapp
// Testing complete.
//
// Revision 1.8  2009/11/27 17:19:21  fperrad
// Implemented feature req. #2718892 for Lua, Perl, PHP, Python, Ruby &Scala
//
// Revision 1.7  2009/11/25 22:30:19  cwrapp
// Fixed problem between %fsmclass and sm file names.
//
// Revision 1.6  2009/11/24 20:42:39  cwrapp
// v. 6.0.1 update
//
// Revision 1.5  2009/10/06 15:31:59  kgreg99
// 1. Started implementation of feature request #2718920.
//     1.1 Added method boolean isStatic() to SmcAction class. It returns false now, but is handled in following language generators: C#, C++, java, php, VB. Instance identificator is not added in case it is set to true.
// 2. Resolved confusion in "emtyStateStack" keyword handling. This keyword was not handled in the same way in all the generators. I added method boolean isEmptyStateStack() to SmcAction class. This method is used instead of different string comparisons here and there. Also the generated method name is fixed, not to depend on name supplied in the input sm file.
//
// Revision 1.4  2009/09/05 15:39:20  cwrapp
// Checking in fixes for 1944542, 1983929, 2731415, 2803547 and feature 2797126.
//
// Revision 1.3  2009/04/22 20:26:29  fperrad
// Added enterStartState method
//
// Revision 1.2  2009/03/27 09:41:47  cwrapp
// Added F. Perrad changes back in.
//
// Revision 1.1  2009/03/01 18:20:42  cwrapp
// Preliminary v. 6.0.0 commit.
//
//
