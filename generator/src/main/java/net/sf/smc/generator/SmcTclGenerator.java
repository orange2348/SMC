//
// The contents of this file are subject to the Mozilla Public
// License Version 1.1 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy
// of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an
// "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
// implied. See the License for the specific language governing
// rights and limitations under the License.
//
// The Original Code is State Machine Compiler (SMC).
//
// The Initial Developer of the Original Code is Charles W. Rapp.
// Portions created by Charles W. Rapp are
// Copyright (C) 2005 - 2009, 2019. Charles W. Rapp.
// All Rights Reserved.
//
// Contributor(s):
//   Eitan Suez contributed examples/Ant.
//   (Name withheld) contributed the C# code generation and
//   examples/C#.
//   Francois Perrad contributed the Python code generation and
//   examples/Python.
//   Chris Liscio contributed the Objective-C code generation
//   and examples/ObjC.
//
// RCS ID
// $Id: SmcTclGenerator.java,v 1.11 2011/11/20 14:58:33 cwrapp Exp $
//
// CHANGE LOG
// (See the bottom of this file.)
//

package net.sf.smc.generator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcFSM;
import net.sf.smc.model.SmcGuard;
import net.sf.smc.model.SmcMap;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.SmcState;
import net.sf.smc.model.SmcTransition;
import net.sf.smc.model.SmcVisitor;
import net.sf.smc.model.TargetLanguage;

/**
 * Visits the abstract syntax tree, emitting [incr Tcl] code.
 * @see SmcElement
 * @see SmcCodeGenerator
 * @see SmcVisitor
 * @see SmcOptions
 *
 * @author <a href="mailto:rapp@acm.org">Charles Rapp</a>
 */

public final class SmcTclGenerator
    extends SmcCodeGenerator
{
//---------------------------------------------------------------
// Member data
//

    //-----------------------------------------------------------
    // Locals.
    //

    // Use this string to fully-qualify names.
    private String mPkgScope;

//---------------------------------------------------------------
// Member methods
//

    //-----------------------------------------------------------
    // Constructors.
    //

    /**
     * Creates a Tcl code generator for the given options.
     * @param options The target code generator options.
     */
    public SmcTclGenerator(final SmcOptions options)
    {
        super (options, TargetLanguage.TCL.suffix());
    } // end of SmcTclGenerator(SmcOptions)

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // SmcVisitor Abstract Method Impelementation.
    //

    /**
     * Emits Tcl code for the finite state machine.
     * @param fsm emit Tcl code for this finite state machine.
     */
    @Override
    public void visit(final SmcFSM fsm)
    {
        String context = fsm.getContext();
        String fsmClassName = fsm.getFsmClassName();
        String rawSource = fsm.getSource();
        String packageName = fsm.getPackage();
        String startState = fsm.getStartState();
        List<SmcMap> maps = fsm.getMaps();
        List<SmcTransition> transitions;
        List<SmcParameter> params;
        String mapName;
        String transName;
        String separator;
        int index = 0;
        Iterator<SmcParameter> pit;

        mTarget.println("# ex: set ro:");
        mTarget.println("# DO NOT EDIT.");
        mTarget.println("# generated by smc (http://smc.sourceforge.net/)");
        mTarget.print("# from file : ");
        mTarget.print(mSrcfileBase);
        mTarget.println(".sm");
        mTarget.println();

        // Now dump out the raw target code, if any.
        if (rawSource != null && rawSource.length() > 0)
        {
            mTarget.println(rawSource);
            mTarget.println();
        }

        // Do user-specified imports now.
        for (String imp: fsm.getImports())
        {
            mTarget.print("package require ");
            mTarget.print(imp);
            mTarget.println(";");
        }
        mTarget.println();

        // If a namespace was specified, then output that
        // namespace now.
        if (packageName != null && packageName.length() > 0)
        {
            mTarget.print("namespace eval ");
            mTarget.print(packageName);
            mTarget.println(" {");
            mTarget.println();
            mIndent = "    ";

            mPkgScope = "::" + packageName + "::";
        }
        else
        {
            mIndent = "";
            mPkgScope = "";
        }

        // Generate the context.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(fsmClassName);
        mTarget.println(" {");
        mTarget.print(mIndent);
        mTarget.println("    inherit ::statemap::FSMContext;");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("# Member functions.");
        mTarget.println();

        // The default constructor.
        mTarget.print(mIndent);
        mTarget.println("    constructor {owner} {");
        mTarget.print(mIndent);
        mTarget.print(
            "        ::statemap::FSMContext::constructor ${");
        mTarget.print(mPkgScope);
        mTarget.print(startState);
        mTarget.println("};");
        mTarget.print(mIndent);
        mTarget.println("    } {");
        mTarget.print(mIndent);
        mTarget.println("        set _owner $owner;");
        mTarget.print(mIndent);
        mTarget.println("    }");

        // For every possible transition in every state map,
        // create a method.
        // First, get the transitions list.
        transitions = fsm.getTransitions();
        for (SmcTransition trans: transitions)
        {
            params = trans.getParameters();

            // Don't do the Default transition.
            if (trans.getName().equals("Default") == false)
            {
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.print("    public method ");
                mTarget.print(trans.getName());
                mTarget.print(" {");

                for (pit = params.iterator(), separator = "";
                     pit.hasNext();
                     separator = " ")
                {
                    mTarget.print(separator);
                    (pit.next()).accept(this);
                }
                mTarget.println("} {");

                mTarget.print(mIndent);
                mTarget.print("        [getState] ");
                mTarget.print(trans.getName());
                mTarget.print(" $this");
                for (SmcParameter param: params)
                {
                    mTarget.print(" $");
                    mTarget.print(param.getName());
                }
                mTarget.println(";");
                mTarget.print(mIndent);
                mTarget.println("        return -code ok;");
                mTarget.print(mIndent);
                mTarget.println("    }");
            }
        }

        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("    public method getOwner {} {");
        mTarget.print(mIndent);
        mTarget.println("        return -code ok $_owner;");
        mTarget.print(mIndent);
        mTarget.println("    }");

        // v. 2.2.0: If we are supporting serialization, then
        // declare the min and max indices.
        if (mSerialFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("    public method valueOf {id} {");
            mTarget.print(mIndent);
            mTarget.println(
                "        if {$id < $MIN_ID || $id > $MAX_ID} {");
            mTarget.print(mIndent);
            mTarget.println("            set retcode error;");
            mTarget.print(mIndent);
            mTarget.print("            set retval ");
            mTarget.println("\"$id is out of bounds\";");
            mTarget.print(mIndent);
            mTarget.println("        } else {");
            mTarget.print(mIndent);
            mTarget.println("            set retcode ok;");
            mTarget.print(mIndent);
            mTarget.println(
                "            set retval $_States($id);");
            mTarget.print(mIndent);
            mTarget.println("        }");
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println(
                "        return -code $retcode $retval;");
            mTarget.print(mIndent);
            mTarget.println("    }");
        }

        // v. 6.0.1: If we are supporting serialization, then
        // declare the getStates method.
        if (mReflectFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("    public method getStates {} {");
            mTarget.print(mIndent);
            mTarget.println("        set retval [list];");
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println(
                "         foreach name [array names _States] {");
            mTarget.print(mIndent);
            mTarget.println(
                "            lappend retval $_States($name);");
            mTarget.print(mIndent);
            mTarget.println("        }");
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println(
                "        return -code ok ${retval};");
            mTarget.print(mIndent);
            mTarget.println("    }");
        }

        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("# Member data.");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("    private variable _owner;");

        // v. 2.2.0: If we are supporting serialization, then
        // declare the min and max indices.
        if (mSerialFlag)
        {
            mTarget.print(mIndent);
            mTarget.println("    private common MIN_ID;");
            mTarget.print(mIndent);
            mTarget.println("    private common MAX_ID;");
        }

        // v. 6.0.1: Generate the states array for both
        // serialization and reflection.
        if (mSerialFlag || mReflectFlag)
        {
            mTarget.print(mIndent);
            mTarget.println("    private common _States;");
        }

        // Put the closing brace on the context class.
        mTarget.print(mIndent);
        mTarget.println("}");
        mTarget.println();

        // Now output the application's state class.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(context);
        mTarget.println("State {");
        mTarget.print(mIndent);
        mTarget.println("    inherit ::statemap::State;");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("# Member functions.");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("    constructor {name id} {");
        mTarget.print(mIndent);
        mTarget.println(
            "        ::statemap::State::constructor $name $id;");
        mTarget.print(mIndent);
        mTarget.println("    } {}");
        mTarget.println();

        // Define the default Entry() and Exit() methods.
        mTarget.print(mIndent);
        mTarget.println("    public method Entry {context} {};");
        mTarget.print(mIndent);
        mTarget.println("    public method Exit {context} {};");

        // Declare the undefined default transitions.
        for (SmcTransition trans: transitions)
        {
            transName = trans.getName();

            // The Default transition is handled separately.
            if (transName.equals("Default") == false)
            {
                mTarget.println();
                mTarget.print(mIndent);
                mTarget.print("    public method ");
                mTarget.print(transName);
                mTarget.print(" {context");
                for (SmcParameter param: trans.getParameters())
                {
                    mTarget.print(" ");
                    param.accept(this);
                }
                mTarget.println("} {");
                mTarget.print(mIndent);
                mTarget.println("        Default $context;");
                mTarget.print(mIndent);
                mTarget.println("        return -code ok;");
                mTarget.print(mIndent);
                mTarget.println("    }");
            }
        }

        // Define the default Default transition.
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("    public method Default {context} {");
        mTarget.print(mIndent);
        mTarget.println(
            "        set transition [$context getTransition];");
        mTarget.print(mIndent);
        mTarget.print("        return -code error ");
        mTarget.print("\"Transition \\\"$transition\\\" ");
        mTarget.print("fell through to a ");
        mTarget.println(
            "non-existent default definition.\";");
        mTarget.print(mIndent);
        mTarget.println("    }");

        // End of the application state class.
        mTarget.print(mIndent);
        mTarget.println("}");
        mTarget.println();

        // Have each map print out its target code in turn.
        for (SmcMap map: maps)
        {
            map.accept(this);
        }

        // Output the static state initialization.
        mTarget.print(mIndent);
        mTarget.println("# Static state declarations.");
        for (SmcMap map: maps)
        {
            mapName = map.getName();

            for (SmcState state: map.getStates())
            {
                mTarget.print(mIndent);
                mTarget.print("set ");
                mTarget.print(mapName);
                mTarget.print("::");
                mTarget.print(state.getInstanceName());
                mTarget.print(" ");

                if (packageName != null &&
                    packageName.length() > 0)
                {
                    mTarget.print(packageName);
                    mTarget.print("::");
                }

                mTarget.print("[");
                mTarget.print(mapName);
                mTarget.print("_");
                mTarget.print(state.getClassName());
                mTarget.print(" #auto \"");
                mTarget.print(mapName);
                mTarget.print("::");
                mTarget.print(state.getClassName());
                mTarget.print("\" ");
                mTarget.print(index);
                mTarget.println("];");

                ++index;
            }
        }

        // If -reflect specified, then generate the transitions
        // class-level data member for each state - but only if
        // the state has transitions.
        if (mReflectFlag)
        {
            SmcState defaultState;
            List<SmcTransition> defaultTransitions;
            List<SmcTransition> stateTransitions;

            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("# Static state transitions.");

            for (SmcMap map: maps)
            {
                defaultState = map.getDefaultState();
                defaultTransitions =
                    defaultState.getTransitions();
                stateTransitions = new ArrayList<>();

                // Generate the default state's transitions
                // first.
                reflectTransitions(defaultState,
                                    stateTransitions,
                                    defaultTransitions,
                                    transitions);

                for (SmcState state: map.getStates())
                {
                    stateTransitions = state.getTransitions();
                    reflectTransitions(state,
                                        stateTransitions,
                                        defaultTransitions,
                                        transitions);

                    ++index;
                }
            }
        }

        // v. 2.2.0: If we are supporting serialization, then
        // declare the min and max indices.
        if (mSerialFlag)
        {
            // Output the state deserialization static data.
            mTarget.print(mIndent);
            mTarget.print("set ");
            mTarget.print(fsmClassName);
            mTarget.println("::MIN_ID 0;");
            mTarget.print(mIndent);
            mTarget.print("set ");
            mTarget.print(fsmClassName);
            mTarget.print("::MAX_ID ");
            mTarget.print(index - 1);
            mTarget.println(";");
        }

        // v. 6.0.1: If we are supporting serialization or
        // reflection, then declare the states array.
        if (mSerialFlag || mReflectFlag)
        {
            mTarget.print(mIndent);
            mTarget.print("array set ");
            mTarget.print(fsmClassName);
            mTarget.print("::_States [list");

            index = 0;
            for (SmcMap map: maps)
            {
                mapName = map.getName();

                for (SmcState state: map.getStates())
                {
                    mTarget.print(" ");
                    mTarget.print(index);
                    mTarget.print(" ${");
                    mTarget.print(mapName);
                    mTarget.print("::");
                    mTarget.print(state.getInstanceName());
                    mTarget.print("}");

                    ++index;
                }
            }
            mTarget.println("];");
        }

        // If necessary, place an end brace for the namespace.
        if (packageName != null && packageName.length() > 0)
        {
            mTarget.println("}");
        }

        mTarget.println();
        mTarget.println("# Local variables:");
        mTarget.println("#  buffer-read-only: t");
        mTarget.println("# End:");

        return;
    } // end of visit(SmcFSM)

    /**
     * Emits Tcl code for the FSM map.
     * @param map emit Tcl code for this map.
     */
    @Override
    public void visit(final SmcMap map)
    {
        List<SmcTransition> definedDefaultTransitions;
        SmcState defaultState = map.getDefaultState();
        String context = map.getFSM().getContext();
        String mapName = map.getName();
        List<SmcState> states = map.getStates();

        if (defaultState != null)
        {
            definedDefaultTransitions =
                    defaultState.getTransitions();
        }
        else
        {
            definedDefaultTransitions = new ArrayList<>();
        }

        // Declare the map class.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.println(" {");
        mTarget.print(mIndent);
        mTarget.println("# Member data.");
        mTarget.println();

        // Print all the static state objects.
        for (SmcState state: states)
        {
            mTarget.print(mIndent);
            mTarget.print("    public common ");
            mTarget.print(state.getClassName());
            mTarget.println(" \"\";");
        }

        // End of map class.
        mTarget.print(mIndent);
        mTarget.println("}");
        mTarget.println();

        // Declare the map's default state class.
        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.println("_Default {");
        mTarget.print(mIndent);
        mTarget.print("    inherit ");
        mTarget.print(context);
        mTarget.println("State;");
        mTarget.println();

        mTarget.print(mIndent);
        mTarget.println("# Member functions.");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("    constructor {name id} {");
        mTarget.print(mIndent);
        mTarget.print("       ");
        mTarget.print(context);
        mTarget.println("State::constructor $name $id;");
        mTarget.print(mIndent);
        mTarget.println("    } {}");

        // If -reflection was specified, then generate the
        // getTransitions method.
        if (mReflectFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println(
                "    public method getTransitions {} {");
            mTarget.print(mIndent);
            mTarget.print("        ");
            mTarget.println(
                "return -code ok [array get _transitions];");
            mTarget.println("    }");
        }

        // Dump out the user-defined default transitions.
        if (defaultState != null)
        {
            for (SmcTransition transition:
                     definedDefaultTransitions)
            {
                transition.accept(this);
            }
        }

        // If -reflect specified, then generate the transitions
        // class data.
        if (mReflectFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("# Member data.");
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("    public common _transitions;");
        }

        // End the map's default state class declaration.
        mTarget.print(mIndent);
        mTarget.println("}");
        mTarget.println();

        // Have each state now generate itself.
        for (SmcState state: states)
        {
            state.accept(this);
        }

        // v. 1.4.0: This functionality moved to
        // SmcFSM.java.
        // Now create each of the static states.
//          for (stateIt = _states.iterator();
//               stateIt.hasNext();
//              )
//          {
//              state = (SmcState) stateIt.next();
//              target.println(indent +
//                             "set " +
//                             mName +
//                             "::" +
//                             state.getClassName() +
//                             " " +
//                             pkg +
//                             "[" +
//                             mName +
//                             "_" +
//                             state.getClassName() +
//                             " #auto \"" +
//                             mName +
//                             "::" +
//                             state.getClassName() +
//                             "\"];");
//          }

        mTarget.println();

        return;
    } // end of visit(SmcMap)

    /**
     * Emits Tcl code for this FSM state.
     * @param state emits Tcl code for this state.
     */
    @Override
    public void visit(final SmcState state)
    {
        String mapName = state.getMap().getName();
        String stateName = state.getClassName();
        List<SmcAction> actions;

        mTarget.print(mIndent);
        mTarget.print("class ");
        mTarget.print(mapName);
        mTarget.print("_");
        mTarget.print(stateName);
        mTarget.println(" {");
        mTarget.print(mIndent);
        mTarget.print("    inherit ");
        mTarget.print(mapName);
        mTarget.println("_Default;");
        mTarget.println();
        mTarget.print(mIndent);
        mTarget.println("    constructor {name id} {");
        mTarget.print(mIndent);
        mTarget.print("        ");
        mTarget.print(mapName);
        mTarget.println("_Default::constructor $name $id;");
        mTarget.print(mIndent);
        mTarget.println("    } {}");

        // If -reflection was specified, then generate the
        // getTransitions method.
        if (mReflectFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println(
                "    public method getTransitions {} {");
            mTarget.print(mIndent);
            mTarget.print("        ");
            mTarget.println(
                "return -code ok [array get _transitions];");
            mTarget.println("    }");
        }

        // Add the Entry() and Exit() member functions if this
        // state defines them.
        actions = state.getEntryActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println(
                "    public method Entry {context} {");

            // Declare the ctxt local variable.
            mTarget.println(
                "        set ctxt [$context getOwner];");
            mTarget.println();

            // Generate the actions associated with this code.
            for (SmcAction action: actions)
            {
                action.accept(this);
            }

            //` End the Entry() method with a return.
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("        return -code ok;");
            mTarget.print(mIndent);
            mTarget.println("    }");
        }

        actions = state.getExitActions();
        if (actions != null && actions.size() > 0)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println(
                "    public method Exit {context} {");

            // Declare the ctxt local variable.
            mTarget.println(
                "        set ctxt [$context getOwner];");
            mTarget.println();

            // Generate the actions associated with this code.
            for (SmcAction action: actions)
            {
                action.accept(this);
            }

            // End the Exit() method with a return.
            mTarget.print(mIndent);
            mTarget.println("        return -code ok;");
            mTarget.print(mIndent);
            mTarget.println("    }");
        }

        // Have the transitions generate their code.
        for (SmcTransition transition: state.getTransitions())
        {
            transition.accept(this);
        }

        // If -reflect specified, then generate the transitions
        // class data.
        if (mReflectFlag)
        {
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("# Member data.");
            mTarget.println();
            mTarget.print(mIndent);
            mTarget.println("    public common _transitions;");
        }

        // End of the state class declaration.
        mTarget.print(mIndent);
        mTarget.println("}");
        mTarget.println();

        return;
    } // end of visit(SmcState)

    /**
     * Emits Tcl code for this FSM state transition.
     * @param transition emits Tcl code for this state transition.
     */
    @Override
    public void visit(final SmcTransition transition)
    {
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String transName = transition.getName();
        List<SmcParameter> parameters =
            transition.getParameters();
        List<SmcGuard> guards = transition.getGuards();
        Iterator<SmcGuard> git = guards.iterator();
        SmcGuard guard;
        SmcGuard nullGuard = null;

        mTarget.println();
        mTarget.print(mIndent);
        mTarget.print("    public method ");
        mTarget.print(transName);
        mTarget.print(" {context");

        // Add user-defined parameters.
        for (SmcParameter param: parameters)
        {
            mTarget.print(" ");
            param.accept(this);
        }

        mTarget.println("} {");

        // All transitions have a "ctxt" local variable.
        // 8/14/2003:
        // Do this only if there are any transition actions or
        // guard conditions which reference it.
        if (transition.hasCtxtReference())
        {
            mTarget.print(mIndent);
            mTarget.println(
                "        set ctxt [$context getOwner];");
        }

        // If this is a default transition, create the loopback
        // flag.
        if (stateName.equals("Default"))
        {
            // Remember this transition's name.
            mTarget.print(mIndent);
            mTarget.print("        set _transition \"");
            mTarget.print(transName);
            mTarget.println("\";");
        }
        else
        {
            mTarget.println();
        }

        // If verbose is turned on, then put the logging code in.
        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            mTarget.print(mIndent);
            mTarget.println(
                "        if {[$context getDebugFlag] != 0} {");
            mTarget.print(mIndent);
            mTarget.print(
                "            puts [$context getDebugStream] ");
            mTarget.print("\"LEAVING STATE   : ");
            mTarget.print(mapName);
            mTarget.print("::");
            mTarget.print(stateName);
            mTarget.println("\";");
            mTarget.print(mIndent);
            mTarget.println("        }");
            mTarget.println();
        }

        mGuardIndex = 0;
        mGuardCount = guards.size();
        while (git.hasNext())
        {
            guard = git.next();

            // Track if there is a guard with no condition.
            if (guard.getCondition().isEmpty())
            {
                nullGuard = guard;
            }
            else
            {
                guard.accept(this);
                ++mGuardIndex;
            }
        }

        // Is there an explicitly defined unguarded transition?
        if (nullGuard != null)
        {
            // Does this guard have any actions or is this guard
            // *not* an internal loopback transition?
            if (nullGuard.hasActions() ||
                !(nullGuard.getEndState()).equals(SmcElement.NIL_STATE) ||
                nullGuard.getTransType() == TransType.TRANS_PUSH ||
                nullGuard.getTransType() == TransType.TRANS_POP)
            {
                // Need to output either the action and/or the
                // next state, so output the guard.
                nullGuard.accept(this);
            }

            mTarget.println();
        }
        // What if all the guards have a condition? There will be
        // no "else" clause. This condition will fall through and
        // do nothing? Is that right? No. If that is the case,
        // then add the "else" clause and have it call this
        // transition's default.
        else if (mGuardIndex > 0)
        {
            if (mGuardCount == 1)
            {
                mTarget.print(mIndent);
                mTarget.print("        }");
            }

            mTarget.println(" else {");
            mTarget.print(mIndent);
            mTarget.print("            ");
            mTarget.print(mapName);
            mTarget.print("_Default ");
            mTarget.print(transName);
            mTarget.print(" $context");

            for (SmcParameter param: parameters)
            {
                mTarget.print(" ");
                mTarget.print(param.getName());
            }

            mTarget.println(";");
            mTarget.print(mIndent);
            mTarget.println("        }");
            mTarget.println();
        }
        else
        {
            mTarget.println();
        }

        mTarget.print(mIndent);
        mTarget.println("        return -code ok;");
        mTarget.print(mIndent);
        mTarget.println("    }");

        return;
    } // end of visit(SmcTransition)

    /**
     * Emits Tcl code for this FSM transition guard.
     * @param guard emits Tcl code for this transition guard.
     */
    @Override
    public void visit(final SmcGuard guard)
    {
        SmcTransition transition = guard.getTransition();
        SmcState state = transition.getState();
        SmcMap map = state.getMap();
        String mapName = map.getName();
        String stateName = state.getClassName();
        String transName = transition.getName();
        TransType transType = guard.getTransType();
        boolean loopbackFlag;
        String indent2;
        String indent3;
        String indent4;
        String endStateName = guard.getEndState();
        String fqEndStateName = "";
        String pushStateName = guard.getPushState();
        String condition = guard.getCondition();
        List<SmcAction> actions = guard.getActions();

        // If this guard's end state is not of the form
        // "map::state", then prepend the map name to the
        // state name.
        // DON'T DO THIS IF THIS IS A POP TRANSITION!
        // The "state is actually a transition name.
        if (transType != TransType.TRANS_POP &&
            endStateName.length () > 0 &&
            !endStateName.equals(SmcElement.NIL_STATE) &&
            !endStateName.contains("::"))
        {
            endStateName = mapName + "::" + endStateName;
        }

        if (!stateName.contains("::"))
        {
            stateName = mapName + "::" + stateName;
        }

        // v. 2.0.2: If the push state is not fully-qualified,
        // then prepend the current map's name and make if
        // fully-qualified.
        if (pushStateName != null &&
            pushStateName.length() > 0 &&
            !pushStateName.contains("::"))
        {
            pushStateName = mapName + "::" + pushStateName;
        }

        loopbackFlag = isLoopback(transType, endStateName);

        // The guard code generation is a bit tricky. The first
        // question is how many guards are there? If there are
        // more than one, then we will need to generate the
        // proper "if-then-else" code.
        if (mGuardCount > 1)
        {
            // Ok, there are multiple guard statements. Now is
            // this the first guard among many?
            if (mGuardIndex == 0 && condition.length() > 0)
            {
                // Yes, this is the first. This means an "if"
                // should be used for this condition.
                mTarget.print(mIndent);
                mTarget.print("        if {");
                mTarget.print(condition);
                mTarget.println("} {");
            }
            else if (condition.length() > 0)
            {
                // No, this is not the first transition but it
                // does have a condition. Use an "else if" for
                // the condition.
                mTarget.print(" elseif {");
                mTarget.print(condition);
                mTarget.println("} {");
            }
            else
            {
                // This is not the first transition and it has
                // no condition.
                mTarget.println(" else {");
            }

            indent2 = mIndent + "            ";
        }
        // There is only one guard. Does this guard have a
        // condition.
        else if (condition.length() == 0)
        {
            // Actually, this is a plain, old, vaniila
            // transition.
            indent2 = mIndent + "        ";
        }
        else
        {
            indent2 = mIndent + "            ";

            // Yes, there is a condition.
            mTarget.print(mIndent);
            mTarget.print("        if {");
            mTarget.print(condition);
            mTarget.println("} {");
        }

        // If this is a pop transition, do not change the
        // "end state" name because it is really a transition.
        if (transType == TransType.TRANS_POP)
        {
            // no-op.
        }
        // Now that the necessary conditions are in place, it's
        // time to dump out the transitions actions. First, do
        // the proper handling of the state change. If this
        // transition has no actions, then set the end state
        // immediately. Otherwise, unset the current state so
        // that if an action tries to issue a transition, it will
        // fail.
        else if (actions.isEmpty() &&
                 endStateName.length() != 0)
        {
            endStateName = "${" + mPkgScope + endStateName + "}";
        }
        else if (actions.size() > 0)
        {
            // Save away the current state if this is a loopback
            // transition. Storing current state allows the
            // current to be cleared before any actions are
            // executed. Remember: actions are not allowed to
            // issue transitions and clearing the current state
            // prevents them from doing so.
            if (loopbackFlag)
            {
                endStateName = "${EndStateName}";
                mTarget.print(indent2);
                mTarget.println(
                    "set EndStateName [$context getState];");
            }
            else
            {
                endStateName =
                    "${" + mPkgScope + endStateName + "}";
            }
        }

        // Perform the current state's exit action.
        // v. 1.0, beta 3: Not any more. The exit actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a pop transition.
        if (transType == TransType.TRANS_POP ||
            loopbackFlag == false)
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.print(indent2);
                mTarget.println(
                    "if {[$context getDebugFlag] != 0} {");
                mTarget.print(indent2);
                mTarget.print(
                    "    puts [$context getDebugStream] ");
                mTarget.print("\"BEFORE EXIT     : \\[");
                mTarget.print(stateName);
                mTarget.println("\\] Exit $context\";");
                mTarget.print(indent2);
                mTarget.println("}");
                mTarget.println();
            }

            mTarget.print(indent2);
            mTarget.println(
                "[$context getState] Exit $context;");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.println();
                mTarget.print(indent2);
                mTarget.println(
                    "if {[$context getDebugFlag] != 0} {");
                mTarget.print(indent2);
                mTarget.print(
                    "    puts [$context getDebugStream] ");
                mTarget.print("\"AFTER EXIT      : \\[");
                mTarget.print(stateName);
                mTarget.println("\\] Exit $context\";");
                mTarget.print(indent2);
                mTarget.println("}");
                mTarget.println();
            }
        }

        if (mDebugLevel >= DEBUG_LEVEL_0)
        {
            List<SmcParameter> parameters =
                transition.getParameters();
            Iterator<SmcParameter> pit;
            String sep;

            mTarget.print(indent2);
            mTarget.println(
                "if {[$context getDebugFlag] != 0} {");
            mTarget.print(indent2);
            mTarget.print(
                "    puts [$context getDebugStream] ");
            mTarget.print("\"ENTER TRANSITION: ");
            mTarget.print(stateName);
            mTarget.print(" ");
            mTarget.print(transName);
            mTarget.print("(");
            for (pit = parameters.iterator(), sep = "";
                 pit.hasNext();
                 sep = ", ")
            {
                mTarget.print(sep);
                (pit.next()).accept(this);
            }
            mTarget.println(")\";");
            mTarget.print(indent2);
            mTarget.println("}");
            mTarget.println();
        }

        // Dump out this transition's actions.
        if (actions.isEmpty())
        {
            indent3 = indent2;

            if (condition.length() > 0)
            {
                mTarget.print(indent2);
                mTarget.println("# No actions.");
            }
        }
        else
        {
            // Now that we are in the transition, clear the
            // current state since we are no longer in a state.
            mTarget.print(indent2);
            mTarget.println("$context clearState;");

            // v. 2.0.2: Place the actions inside a catch block.
            // If one of the actions raises an error, the catch
            // block will make sure the state is set before
            // re-raising the error.
            // v. 2.2.0: Check if the user has turned off this
            // feature first.
            if (mNoCatchFlag == false)
            {
                indent3 = indent2 + "    ";

                mTarget.print(indent2);
                mTarget.println("if [catch {");
            }
            else
            {
                indent3 = indent2;
            }

            indent4 = mIndent;
            mIndent = indent3;
            for (SmcAction action: actions)
            {
                action.accept(this);
            }
            mIndent = indent4;

            if (mDebugLevel >= DEBUG_LEVEL_0)
            {
                List<SmcParameter> parameters =
                    transition.getParameters();
                Iterator<SmcParameter> pit;
                String sep;

                mTarget.print(indent3);
                mTarget.println(
                    "if {[$context getDebugFlag] != 0} {");
                mTarget.print(indent3);
                mTarget.print(
                    "    puts [$context getDebugStream] ");
                mTarget.print("\"EXIT TRANSITION : ");
                mTarget.print(stateName);
                mTarget.print(" ");
                mTarget.print(transName);
                mTarget.print("(");
                for (pit = parameters.iterator(), sep = "";
                     pit.hasNext();
                     sep = ", ")
                {
                    mTarget.print(sep);
                    (pit.next()).accept(this);
                }
                mTarget.println(")\";");
                mTarget.print(indent3);
                mTarget.println("}");
                mTarget.println();
            }

            // v. 2.2.0: Check if the user has turned off this
            // feature first.
            if (mNoCatchFlag == false)
            {
                mTarget.print(indent2);
                mTarget.println("} result] {");

                // v. 2.0.2: Generate the set state, push or pop
                // code for the if's then body. Note: the catch
                // body was generated only if there were actions.
                if (transType == TransType.TRANS_SET)
                {
                    mTarget.print(indent3);
                    mTarget.print("$context setState ");
                    mTarget.print(endStateName);
                    mTarget.println(";");
                }
                else if (transType == TransType.TRANS_PUSH)
                {
                    mTarget.print(indent3);
                    mTarget.print("$context setState ");
                    mTarget.print(endStateName);
                    mTarget.println(";");

                    // Before doing the push, execute the end
                    // state's entry actions (if any) if this is
                    // not a loopback.
                    if (loopbackFlag == false)
                    {
                        if (mDebugLevel >= DEBUG_LEVEL_1)
                        {
                            mTarget.println();
                            mTarget.print(indent3);
                            mTarget.println(
                                "if {[$context getDebugFlag] != 0} {");
                            mTarget.print(indent3);
                            mTarget.print(
                                "    puts [$context getDebugStream] ");
                            mTarget.print("\"BEFORE ENTRY    : \\[");
                            mTarget.print(fqEndStateName);
                            mTarget.println("\\] Entry $context\";");
                            mTarget.print(indent3);
                            mTarget.println("}");
                            mTarget.println();
                        }

                        mTarget.println();
                        mTarget.print(indent3);
                        mTarget.println(
                            "[$context getState] Entry $context;");
                        mTarget.println();

                        if (mDebugLevel >= DEBUG_LEVEL_1)
                        {
                            mTarget.println();
                            mTarget.print(indent3);
                            mTarget.println(
                                "if {[$context getDebugFlag] != 0} {");
                            mTarget.print(indent3);
                            mTarget.print(
                                "    puts [$context getDebugStream] ");
                            mTarget.print("\"AFTER ENTRY     : \\[");
                            mTarget.print(fqEndStateName);
                            mTarget.println("\\] Exit $context\";");
                            mTarget.print(indent3);
                            mTarget.println("}");
                            mTarget.println();
                        }
                    }

                    mTarget.print(indent3);
                    mTarget.print("$context pushState ${");
                    mTarget.print(mPkgScope);
                    mTarget.print(pushStateName);
                    mTarget.println("};");
                }
                else if (transType == TransType.TRANS_POP)
                {
                    mTarget.print(indent3);
                    mTarget.println("$context popState;");
                }

                // Re-throw the caught Tcl error so the
                // application may now see it.
                mTarget.print(indent3);
                mTarget.println("error $result;");

                // Close off the then body and start the else
                // body.
                mTarget.print(indent2);
                mTarget.println("} else {");
            }
        }

        // Print the setState() call, if necessary. Do NOT
        // generate the set state if:
        // 1. The transition has no actions AND is a loopback OR
        // 2. This is a push or pop transition.
        //
        // v. 2.0.2: The following code must be generated twice -
        // once for the catch body and again in the if's then
        // body.
        if (transType == TransType.TRANS_SET &&
            (actions.size() > 0 ||
             loopbackFlag == false))
        {
            mTarget.print(indent3);
            mTarget.print("$context setState ");
            mTarget.print(endStateName);
            mTarget.println(";");
        }
        else if (transType == TransType.TRANS_PUSH)
        {
            // Set the next state so that it can be pushed
            // onto the state stack. But only do so if a clear
            // state was done.
            if (loopbackFlag == false || actions.size() > 0)
            {
                mTarget.print(indent3);
                mTarget.print("$context setState ");
                mTarget.print(endStateName);
                mTarget.println(";");
            }

            // Before doing the push, execute the end state's
            // entry actions (if any) if this is not a loopback.
            if (loopbackFlag == false)
            {
                if (mDebugLevel >= DEBUG_LEVEL_1)
                {
                    mTarget.println();
                    mTarget.print(indent3);
                    mTarget.println(
                        "if {[$context getDebugFlag] != 0} {");
                    mTarget.print(indent3);
                    mTarget.print(
                        "    puts [$context getDebugStream] ");
                    mTarget.print("\"BEFORE ENTRY    : \\[");
                    mTarget.print(fqEndStateName);
                    mTarget.println("\\] Exit $context\";");
                    mTarget.print(indent3);
                    mTarget.println("}");
                    mTarget.println();
                }

                mTarget.println();
                mTarget.print(indent3);
                mTarget.println(
                    "[$context getState] Entry $context;");
                mTarget.println();

                if (mDebugLevel >= DEBUG_LEVEL_1)
                {
                    mTarget.println();
                    mTarget.print(indent3);
                    mTarget.println(
                        "if {[$context getDebugFlag] != 0} {");
                    mTarget.print(indent3);
                    mTarget.print(
                        "    puts [$context getDebugStream] ");
                    mTarget.print("\"AFTER ENTRY     : \\[");
                    mTarget.print(fqEndStateName);
                    mTarget.println("\\] Entry $context\";");
                    mTarget.print(indent3);
                    mTarget.println("}");
                    mTarget.println();
                }
            }

            mTarget.print(indent3);
            mTarget.print("$context pushState ${");
            mTarget.print(mPkgScope);
            mTarget.print(pushStateName);
            mTarget.println("};");
        }
        else if (transType == TransType.TRANS_POP)
        {
            mTarget.print(indent3);
            mTarget.println("$context popState;");
        }

        // Close off the else body if there is one.
        // v. 2.2.0: There won't be one if the user turned off
        // guards.
        if (actions.size() > 0 && mNoCatchFlag == false)
        {
            mTarget.print(indent2);
            mTarget.println("}");
        }

        // Perform the new state's entry actions.
        // v. 1.0, beta 3: Not any more. The entry actions are
        // executed only if 1) this is a standard, non-loopback
        // transition or a push transition.
        if ((transType == TransType.TRANS_SET &&
             loopbackFlag == false) ||
             transType == TransType.TRANS_PUSH)
        {
            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.println();
                mTarget.print(indent2);
                mTarget.println(
                    "if {[$context getDebugFlag] != 0} {");
                mTarget.print(indent2);
                mTarget.print(
                    "    puts [$context getDebugStream] ");
                mTarget.print("\"BEFORE ENTRY    : \\[");
                mTarget.print(fqEndStateName);
                mTarget.println("\\] Entry $context\";");
                mTarget.print(indent2);
                mTarget.println("}");
                mTarget.println();
            }

            mTarget.print(indent2);
            mTarget.println(
                "[$context getState] Entry $context;");

            if (mDebugLevel >= DEBUG_LEVEL_1)
            {
                mTarget.println();
                mTarget.print(indent2);
                mTarget.println(
                    "if {[$context getDebugFlag] != 0} {");
                mTarget.print(indent2);
                mTarget.print(
                    "    puts [$context getDebugStream] ");
                mTarget.print("\"AFTER ENTRY     : \\[");
                mTarget.print(fqEndStateName);
                mTarget.println("\\] Entry $context\";");
                mTarget.print(indent2);
                mTarget.println("}");
                mTarget.println();
            }
        }

        // If there is a transition associated with the pop, then
        // issue that transition here.
        if (transType == TransType.TRANS_POP &&
            endStateName.equals(SmcElement.NIL_STATE) == false &&
            endStateName.length() > 0)
        {
            String popArgs = guard.getPopArgs();

            mTarget.println();
            mTarget.print(indent2);
            mTarget.print("$context ");
            mTarget.print(endStateName);

            // Output any and all pop arguments.
            if (popArgs.length() > 0)
            {
                mTarget.print(" ");
                mTarget.print(popArgs);
            }

            mTarget.println(";");
        }

        // If this is a guarded transition, it will be necessary
        // to close off the if body. DON'T PRINT A NEW LINE. Why?
        // Because an else or elseif may follow and we won't know
        // until we go back to the transition target generator
        // whether all clauses have been done.
        if (mGuardCount > 1)
        {
            mTarget.print(mIndent);
            mTarget.print("        }");
        }

        return;
    } // end of visit(SmcGuard)

    /**
     * Emits Tcl code for this FSM action.
     * @param action emits Tcl code for this action.
     */
    @Override
    public void visit(final SmcAction action)
    {
        String name = action.getName();

        mTarget.print(mIndent);

        // Need to distinguish between FSMContext actions and
        // application class actions. If the action is
        // "emptyStateStack", then pass it to the context.
        // Otherwise, let the application class handle it.
        if (action.isEmptyStateStack())
        {
            mTarget.println("$context emptyStateStack;");
        }
        else
        {
            mTarget.print("$ctxt ");

	        mTarget.print(name);

	        for (String arg: action.getArguments())
	        {
	            mTarget.print(" ");
	            mTarget.print(arg);
	        }

	        mTarget.println(";");
        }
        return;
    } // end of visit(SmcAction)

    /**
     * Emits Tcl code for this transition parameter.
     * @param parameter emits Tcl code for this transition
     * parameter.
     */
    @Override
    public void visit(final SmcParameter parameter)
    {
        // v. 2.0.2: Tcl differentiates between
        // call-by-value and call-by-name. If this is
        // call-by-value, prepend the name with a "$".
        if (parameter.getType().equals("value"))
        {
            mTarget.print("$");
        }

        // Types? Types?!!! We don't need no stinkin' types!
        // I'm Tcl dammit!
        mTarget.print(parameter.getName());

        return;
    } // end of visit(SmcParameter)

    //
    // end of SmcVisitor Abstract Method Impelementation.
    //-----------------------------------------------------------

    // Returns the _transition initializations for reflection.
    private void reflectTransitions(final SmcState state,
                                    final List<SmcTransition> stateTransitions,
                                    final List<SmcTransition> defaultTransitions,
                                    final List<SmcTransition> allTransitions)
    {
        Iterator<SmcTransition> it;
        SmcTransition transition;
        String transName;
        int transDefinition;
        String sep;

        mTarget.print(mIndent);
        mTarget.print("array set ");
        mTarget.print(state.getMap().getName());
        mTarget.print("_");
        mTarget.print(state.getClassName());
        mTarget.print("::_transitions {");

        for (it = allTransitions.iterator(), sep = "";
             it.hasNext();
             sep = " ")
        {
            transition = it.next();
            transName = transition.getName();

            // If the transition is in this state, then its
            // value is 1.
            if (stateTransitions.contains(transition))
            {
                transDefinition = 1;
            }
            // If the transition is defined in this map's
            // default state, then the value is 2.
            else if (defaultTransitions.contains(transition))
            {
                transDefinition = 2;
            }
            // Otherwise the value is 0 - undefined.
            else
            {
                transDefinition = 0;
            }

            mTarget.print(sep);
            mTarget.print("\"");
            mTarget.print(transName);
            mTarget.print("\" ");
            mTarget.print(transDefinition);
        }

        mTarget.println("};");

        return;
    } // end of reflectTransitions(SmcState, List, List, List)
} // end of class SmcTclGenerator

//
// CHANGE LOG
// $Log: SmcTclGenerator.java,v $
// Revision 1.11  2011/11/20 14:58:33  cwrapp
// Check in for SMC v. 6.1.0
//
// Revision 1.10  2009/12/17 19:51:43  cwrapp
// Testing complete.
//
// Revision 1.9  2009/11/25 22:30:19  cwrapp
// Fixed problem between %fsmclass and sm file names.
//
// Revision 1.8  2009/11/24 20:42:39  cwrapp
// v. 6.0.1 update
//
// Revision 1.7  2009/10/06 15:31:59  kgreg99
// 1. Started implementation of feature request #2718920.
//     1.1 Added method boolean isStatic() to SmcAction class. It returns false now, but is handled in following language generators: C#, C++, java, php, VB. Instance identificator is not added in case it is set to true.
// 2. Resolved confusion in "emtyStateStack" keyword handling. This keyword was not handled in the same way in all the generators. I added method boolean isEmptyStateStack() to SmcAction class. This method is used instead of different string comparisons here and there. Also the generated method name is fixed, not to depend on name supplied in the input sm file.
//
// Revision 1.6  2009/09/12 21:44:49  kgreg99
// Implemented feature req. #2718941 - user defined generated class name.
// A new statement was added to the syntax: %fsmclass class_name
// It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
// If used, generated class is called asrequested.
// Following language generators are touched:
// c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
// This feature is not tested yet !
// Maybe it will be necessary to modify also the output file name.
//
// Revision 1.5  2009/09/05 15:39:20  cwrapp
// Checking in fixes for 1944542, 1983929, 2731415, 2803547 and feature 2797126.
//
// Revision 1.4  2009/04/25 14:25:40  cwrapp
// Removed context class initial state constructor as Tcl does not support multiple constructors.
//
// Revision 1.3  2009/04/10 14:07:00  cwrapp
// Added initial state constructor.
//
// Revision 1.2  2009/03/27 09:41:47  cwrapp
// Added F. Perrad changes back in.
//
// Revision 1.1  2009/03/01 18:20:42  cwrapp
// Preliminary v. 6.0.0 commit.
//
// Revision 1.7  2008/03/21 14:03:17  fperrad
// refactor : move from the main file Smc.java to each language generator the following data :
//  - the default file name suffix,
//  - the file name format for the generated SMC files
//
// Revision 1.6  2007/08/05 14:36:12  cwrapp
// Version 5.0.1 check-in. See net/sf/smc/CODE_README.txt for more informaiton.
//
// Revision 1.5  2007/02/21 13:56:54  cwrapp
// Moved Java code to release 1.5.0
//
// Revision 1.4  2007/01/15 00:23:52  cwrapp
// Release 4.4.0 initial commit.
//
// Revision 1.3  2006/09/16 15:04:29  cwrapp
// Initial v. 4.3.3 check-in.
//
// Revision 1.2  2005/11/07 19:34:54  cwrapp
// Changes in release 4.3.0:
// New features:
//
// + Added -reflect option for Java, C#, VB.Net and Tcl code
//   generation. When used, allows applications to query a state
//   about its supported transitions. Returns a list of transition
//   names. This feature is useful to GUI developers who want to
//   enable/disable features based on the current state. See
//   Programmer's Manual section 11: On Reflection for more
//   information.
//
// + Updated LICENSE.txt with a missing final paragraph which allows
//   MPL 1.1 covered code to work with the GNU GPL.
//
// + Added a Maven plug-in and an ant task to a new tools directory.
//   Added Eiten Suez's SMC tutorial (in PDF) to a new docs
//   directory.
//
// Fixed the following bugs:
//
// + (GraphViz) DOT file generation did not properly escape
//   double quotes appearing in transition guards. This has been
//   corrected.
//
// + A note: the SMC FAQ incorrectly stated that C/C++ generated
//   code is thread safe. This is wrong. C/C++ generated is
//   certainly *not* thread safe. Multi-threaded C/C++ applications
//   are required to synchronize access to the FSM to allow for
//   correct performance.
//
// + (Java) The generated getState() method is now public.
//
// Revision 1.1  2005/05/28 19:28:42  cwrapp
// Moved to visitor pattern.
//
// Revision 1.2  2005/02/21 15:38:32  charlesr
// Added Francois Perrad to Contributors section for Python work.
//
// Revision 1.1  2005/02/21 15:22:14  charlesr
// Modified isLoopback method call to new signature due to moving
// method from SmcGuard to SmcCodeGenerator.
//
// Revision 1.0  2005/02/03 17:12:44  charlesr
// Initial revision
//
