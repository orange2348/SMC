/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : SmcParser.sm
 */


/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is State Machine Compiler (SMC).
 *
 * The Initial Developer of the Original Code is Charles W. Rapp.
 * Portions created by Charles W. Rapp are
 * Copyright (C) 2000 - 2005, 2008, 2013. Charles W. Rapp.
 * All Rights Reserved.
 *
 * Contributor(s):
 *   Eitan Suez contributed examples/Ant.
 *   (Name withheld) contributed the C# code generation and
 *   examples/C#.
 *   Francois Perrad contributed the Python code generation and
 *   examples/Python, Perl code generation and examples/Perl,
 *   Ruby code generation and examples/Ruby, Lua code generation
 *   and examples/Lua, Groovy code generation and examples/Groovy.
 *   Chris Liscio contributed the Objective-C code generation
 *   and examples/ObjC.
 *
 * smcParser --
 *
 *  This state machine defines the  state machine language.
 *
 * RCS ID
 * $Id: SmcParser.sm,v 1.10 2015/08/02 19:44:36 cwrapp Exp $
 *
 * CHANGE LOG
 * $Log: SmcParser.sm,v $
 * Revision 1.10  2015/08/02 19:44:36  cwrapp
 * Release 6.6.0 commit.
 *
 * Revision 1.9  2013/12/15 16:31:20  fperrad
 * full refactor of JavaScript
 *
 * Revision 1.8  2013/07/14 14:32:39  cwrapp
 * check in for release 6.2.0
 *
 * Revision 1.7  2010/03/05 21:29:54  fperrad
 * Allows property with Groovy, Lua, Perl, Python, Ruby & Scala
 *
 * Revision 1.6  2010/03/03 19:18:41  fperrad
 * fix property with Graph & Table
 *
 * Revision 1.5  2009/09/12 21:44:49  kgreg99
 * Implemented feature req. #2718941 - user defined generated class name.
 * A new statement was added to the syntax: %fsmclass class_name
 * It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
 * If used, generated class is called asrequested.
 * Following language generators are touched:
 * c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
 * This feature is not tested yet !
 * Maybe it will be necessary to modify also the output file name.
 *
 * Revision 1.4  2009/04/11 13:11:13  cwrapp
 * Corrected raw mode 3 to handle multiple argument template/generic declarations.
 *
 * Revision 1.3  2009/03/27 09:41:47  cwrapp
 * Added F. Perrad changes back in.
 *
 * Revision 1.2  2009/03/03 17:28:53  kgreg99
 * 1. Bugs resolved:
 * #2657779 - modified SmcParser.sm and SmcParserContext.java
 * #2648516 - modified SmcCSharpGenerator.java
 * #2648472 - modified SmcSyntaxChecker.java
 * #2648469 - modified SmcMap.java
 *
 * Revision 1.1  2009/03/01 18:20:42  cwrapp
 * Preliminary v. 6.0.0 commit.
 *
 * Revision 1.21  2008/08/16 14:31:37  fperrad
 * + detabify
 *
 * Revision 1.20  2008/04/22 16:05:24  fperrad
 * - add PHP language (patch from Toni Arnold)
 *
 * Revision 1.19  2008/01/22 08:56:55  fperrad
 * - fix : allows Perl parameter with graph generation
 *
 * Revision 1.18  2007/11/19 18:53:21  fperrad
 * + add : jump syntax
 *   jump uses the same syntax as push,
 *   allows transition between states of different maps but without stacking a return context.
 *
 * Revision 1.17  2007/07/16 06:28:06  fperrad
 * + Added Groovy generator.
 *
 * Revision 1.16  2007/02/21 13:56:16  cwrapp
 * Moved Java code to release 1.5.0
 *
 * Revision 1.15  2007/01/15 00:23:51  cwrapp
 * Release 4.4.0 initial commit.
 *
 * Revision 1.14  2007/01/03 15:23:05  fperrad
 * + Added Lua generator.
 *
 * Revision 1.13  2006/09/16 15:04:29  cwrapp
 * Initial v. 4.3.3 check-in.
 *
 * Revision 1.12  2006/07/11 18:17:01  cwrapp
 * Removed errors regarding percent keywords.
 *
 * Revision 1.11  2006/04/22 12:45:26  cwrapp
 * Version 4.3.1
 *
 * Revision 1.10  2005/09/14 01:51:33  cwrapp
 * Changes in release 4.2.0:
 * New features:
 *
 * None.
 *
 * Fixed the following bugs:
 *
 * + (Java) -java broken due to an untested minor change.
 *
 * Revision 1.9  2005/08/26 15:21:34  cwrapp
 * Final commit for release 4.2.0. See README.txt for more information.
 *
 * Revision 1.8  2005/07/07 12:11:56  fperrad
 * Add a new token '$' for Perl language.
 * The type of parameter is optional for Python, Per & Ruby.
 *
 * Revision 1.7  2005/06/30 10:44:23  cwrapp
 * Added %access keyword which allows developers to set the generate Context
 * class' accessibility level in Java and C#.
 *
 * Revision 1.6  2005/05/28 19:28:42  cwrapp
 * Moved to visitor pattern.
 *
 * Revision 1.5  2005/02/21 15:37:52  charlesr
 * Added Francois Perrad to Contributors section for Python work.
 *
 * Revision 1.4  2005/02/21 15:21:21  charlesr
 * Added -graph target as allowing %include, %declare and %import.
 *
 * Revision 1.3  2005/02/03 17:06:21  charlesr
 * SmcParser.warning() and .error() methods now take a line
 * number argument. All calls to these method within the
 * parser's FSM have been modified.
 *
 * Revision 1.2  2004/09/06 16:41:32  charlesr
 * Added "property = value" syntax. Added C# support.
 *
 * Revision 1.1  2004/05/31 13:56:34  charlesr
 * Added support for VB.net code generation.
 *
 * Revision 1.0  2003/12/14 21:06:00  charlesr
 * Initial revision
 *
 */


package net.sf.smc.parser;

import java.util.List;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.TargetLanguage;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.invoke.MethodType;
import statemap.FSMContext7;
import statemap.State7;
import statemap.TransitionHandle;

public final class SmcParserContext
    extends FSMContext7
{
//---------------------------------------------------------------
// Member methods.
//

    //-----------------------------------------------------------
    // Constructors.
    //

    public SmcParserContext(final SmcParser owner)
    {
        this (owner, _States[ParserMap_Start_STATE_ID]);
    }

    public SmcParserContext(final SmcParser owner, final int initStateId)
    {
        this (owner, _States[initStateId]);    }

    public SmcParserContext(final SmcParser owner, final State7 initState)
    {
        super (initState);

        ctxt = owner;
    }

    //
    // end of Constructors.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // FSMContext7 Abstract Method Override.
    //

    @Override
    protected void executeAction(final MethodHandle mh)
    {
        try
        {
            mh.invokeExact(this);
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }

        return;
    }

    //
    // end of FSMContext7 Abstract Method Override.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // Transitions.
    //

    public void ACCESS(SmcLexer.Token token)
    {
        mTransition = "ACCESS";
        try
        {
            final TransitionHandle th =
                getState().transition(ACCESS42_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void CLASS_NAME(SmcLexer.Token token)
    {
        mTransition = "CLASS_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(CLASS_NAME35_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void COLON(SmcLexer.Token token)
    {
        mTransition = "COLON";
        try
        {
            final TransitionHandle th =
                getState().transition(COLON175_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void COMMA(SmcLexer.Token token)
    {
        mTransition = "COMMA";
        try
        {
            final TransitionHandle th =
                getState().transition(COMMA199_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void DECLARE(SmcLexer.Token token)
    {
        mTransition = "DECLARE";
        try
        {
            final TransitionHandle th =
                getState().transition(DECLARE41_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void DOLLAR(SmcLexer.Token token)
    {
        mTransition = "DOLLAR";
        try
        {
            final TransitionHandle th =
                getState().transition(DOLLAR171_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void ENTRY(SmcLexer.Token token)
    {
        mTransition = "ENTRY";
        try
        {
            final TransitionHandle th =
                getState().transition(ENTRY71_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void EOD(SmcLexer.Token token)
    {
        mTransition = "EOD";
        try
        {
            final TransitionHandle th =
                getState().transition(EOD59_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void EQUAL(SmcLexer.Token token)
    {
        mTransition = "EQUAL";
        try
        {
            final TransitionHandle th =
                getState().transition(EQUAL188_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void EXIT(SmcLexer.Token token)
    {
        mTransition = "EXIT";
        try
        {
            final TransitionHandle th =
                getState().transition(EXIT72_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void FSM_CLASS_NAME(SmcLexer.Token token)
    {
        mTransition = "FSM_CLASS_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(FSM_CLASS_NAME36_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void FSM_FILE_NAME(SmcLexer.Token token)
    {
        mTransition = "FSM_FILE_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(FSM_FILE_NAME37_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void HEADER_FILE(SmcLexer.Token token)
    {
        mTransition = "HEADER_FILE";
        try
        {
            final TransitionHandle th =
                getState().transition(HEADER_FILE38_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void IMPORT(SmcLexer.Token token)
    {
        mTransition = "IMPORT";
        try
        {
            final TransitionHandle th =
                getState().transition(IMPORT40_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void INCLUDE_FILE(SmcLexer.Token token)
    {
        mTransition = "INCLUDE_FILE";
        try
        {
            final TransitionHandle th =
                getState().transition(INCLUDE_FILE7_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void JUMP(SmcLexer.Token token)
    {
        mTransition = "JUMP";
        try
        {
            final TransitionHandle th =
                getState().transition(JUMP122_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void LEFT_BRACE(SmcLexer.Token token)
    {
        mTransition = "LEFT_BRACE";
        try
        {
            final TransitionHandle th =
                getState().transition(LEFT_BRACE167_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void LEFT_BRACKET(SmcLexer.Token token)
    {
        mTransition = "LEFT_BRACKET";
        try
        {
            final TransitionHandle th =
                getState().transition(LEFT_BRACKET113_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void LEFT_PAREN(SmcLexer.Token token)
    {
        mTransition = "LEFT_PAREN";
        try
        {
            final TransitionHandle th =
                getState().transition(LEFT_PAREN187_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void MAP_NAME(SmcLexer.Token token)
    {
        mTransition = "MAP_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(MAP_NAME65_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void PACKAGE_NAME(SmcLexer.Token token)
    {
        mTransition = "PACKAGE_NAME";
        try
        {
            final TransitionHandle th =
                getState().transition(PACKAGE_NAME39_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void POP(SmcLexer.Token token)
    {
        mTransition = "POP";
        try
        {
            final TransitionHandle th =
                getState().transition(POP121_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void PUSH(SmcLexer.Token token)
    {
        mTransition = "PUSH";
        try
        {
            final TransitionHandle th =
                getState().transition(PUSH130_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void RIGHT_BRACE(SmcLexer.Token token)
    {
        mTransition = "RIGHT_BRACE";
        try
        {
            final TransitionHandle th =
                getState().transition(RIGHT_BRACE196_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void RIGHT_PAREN(SmcLexer.Token token)
    {
        mTransition = "RIGHT_PAREN";
        try
        {
            final TransitionHandle th =
                getState().transition(RIGHT_PAREN200_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void SEMICOLON(SmcLexer.Token token)
    {
        mTransition = "SEMICOLON";
        try
        {
            final TransitionHandle th =
                getState().transition(SEMICOLON192_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void SLASH(SmcLexer.Token token)
    {
        mTransition = "SLASH";
        try
        {
            final TransitionHandle th =
                getState().transition(SLASH127_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void SOURCE(SmcLexer.Token token)
    {
        mTransition = "SOURCE";
        try
        {
            final TransitionHandle th =
                getState().transition(SOURCE202_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void START_STATE(SmcLexer.Token token)
    {
        mTransition = "START_STATE";
        try
        {
            final TransitionHandle th =
                getState().transition(START_STATE34_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void WORD(SmcLexer.Token token)
    {
        mTransition = "WORD";
        try
        {
            final TransitionHandle th =
                getState().transition(WORD184_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, token);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void actionsDone(List<SmcAction> actions, int lineNumber)
    {
        mTransition = "actionsDone";
        try
        {
            final TransitionHandle th =
                getState().transition(actionsDone165_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, actions, lineNumber);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void actionsError()
    {
        mTransition = "actionsError";
        try
        {
            final TransitionHandle th =
                getState().transition(actionsError166_TRANSITION_ID);

            (th.handle()).invokeExact(this);
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void argsDone(List<String> args)
    {
        mTransition = "argsDone";
        try
        {
            final TransitionHandle th =
                getState().transition(argsDone190_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, args);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void argsError()
    {
        mTransition = "argsError";
        try
        {
            final TransitionHandle th =
                getState().transition(argsError191_TRANSITION_ID);

            (th.handle()).invokeExact(this);
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void paramsDone(List<SmcParameter> params, int lineNumber)
    {
        mTransition = "paramsDone";
        try
        {
            final TransitionHandle th =
                getState().transition(paramsDone104_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, params, lineNumber);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    public void paramsError(List<SmcParameter> params, int lineNumber)
    {
        mTransition = "paramsError";
        try
        {
            final TransitionHandle th =
                getState().transition(paramsError105_TRANSITION_ID);

            if (th.isDefault() == true)
            {
                (th.handle()).invokeExact(this);
            }
            else
            {
                (th.handle()).invokeExact(this, params, lineNumber);
            }
        }
        catch (Throwable tex)
        {
            if (mDebugFlag == true)
            {
                tex.printStackTrace(mDebugStream);
            }
        }
        mTransition = "";
        return;
    }

    //
    // end of Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Start State Transitions.
    //

    private void ParserMap_Start_ACCESS(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Access_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Context_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_DECLARE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Declare_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting \"%{ source %}\", %start, or %class.", ctxt.getLineNumber());
            ctxt.setHeaderLine(ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_FSM_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_FsmClassName_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_FSM_FILE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_FsmFileName_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_HEADER_FILE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_HeaderFile_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_IMPORT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Import_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_INCLUDE_FILE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_IncludeFile_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isValidHeader())
        {
            exitState();

            try
            {
                clearState();
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_MapName_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_StartError_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    private void ParserMap_Start_PACKAGE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_Package_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Start_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.setSource(token.getValue());
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[stateId]);
        }


        return;
    }


    private void ParserMap_Start_START_STATE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartState_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Context State Transitions.
    //

    private void ParserMap_Context_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing name after %class.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Context_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setContext(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.Context State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StartState State Transitions.
    //

    private void ParserMap_StartState_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing state after %start.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartState_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isValidStartState(token.getValue()))
        {
            exitState();

            try
            {
                clearState();
                ctxt.setStartState(token.getValue());
            }
            finally
            {
                setState(_States[ParserMap_Start_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Start state must be of the form \"map::state\".", token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_StartError_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    //
    // end of ParserMap.StartState State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.HeaderFile State Entry/Exit Actions.
    //

    private void ParserMap_HeaderFile__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_HeaderFile__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.HeaderFile State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.HeaderFile State Transitions.
    //

    private void ParserMap_HeaderFile_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing header file after %header.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_HeaderFile_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeader(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.HeaderFile State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.IncludeFile State Entry/Exit Actions.
    //

    private void ParserMap_IncludeFile__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_IncludeFile__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.IncludeFile State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.IncludeFile State Transitions.
    //

    private void ParserMap_IncludeFile_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing include file after %include.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_IncludeFile_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addInclude(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.IncludeFile State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Package State Transitions.
    //

    private void ParserMap_Package_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing name after %package.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Package_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setPackageName(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.Package State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.FsmClassName State Transitions.
    //

    private void ParserMap_FsmClassName_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing name after %FsmClassName.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_FsmClassName_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setFsmClassName(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.FsmClassName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.FsmFileName State Transitions.
    //

    private void ParserMap_FsmFileName_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing name after %FsmClassName.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_FsmFileName_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setFsmFileName(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.FsmFileName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Import State Entry/Exit Actions.
    //

    private void ParserMap_Import__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_Import__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.Import State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Import State Transitions.
    //

    private void ParserMap_Import_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing name after %import.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Import_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addImport(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.Import State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Declare State Entry/Exit Actions.
    //

    private void ParserMap_Declare__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_Declare__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.Declare State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Declare State Transitions.
    //

    private void ParserMap_Declare_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing name after %declare.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Declare_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addDeclare(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.Declare State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Access State Entry/Exit Actions.
    //

    private void ParserMap_Access__Entry_()
    {
        ctxt.setRawMode("\n\r\f");
    }

    private void ParserMap_Access__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.Access State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Access State Transitions.
    //

    private void ParserMap_Access_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing access level after %access.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Access_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setAccessLevel(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.Access State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StartError State Transitions.
    //

    private void ParserMap_StartError_ACCESS(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_Access_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Context_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_DECLARE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Declare_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_StartError_FSM_CLASS_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_FsmClassName_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_FSM_FILE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_FsmFileName_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_HEADER_FILE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_HeaderFile_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_IMPORT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Import_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isValidHeader())
        {
            exitState();

            try
            {
                clearState();
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_MapName_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_StartError_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    private void ParserMap_StartError_PACKAGE_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_Package_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StartError_START_STATE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setHeaderLine(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StartState_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.StartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStart State Transitions.
    //

    private void ParserMap_MapStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting %map.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_MapStartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_MapStart_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_MapName_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.MapStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStartError State Transitions.
    //

    private void ParserMap_MapStartError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_MapStartError_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_MapName_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.MapStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapName State Transitions.
    //

    private void ParserMap_MapName_Default()
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.error("Name expected after \"%map\".", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[stateId]);
        }


        return;
    }


    private void ParserMap_MapName_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Name expected after \"%map\".", token.getLineNumber());
            ctxt.createMap(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_States_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_MapName_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDuplicateMap(token.getValue()))
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Duplicate map name.", token.getLineNumber());
                ctxt.createMap(token.getValue(), token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_MapStates_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.createMap(token.getValue(), token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_MapStates_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    //
    // end of ParserMap.MapName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStates State Transitions.
    //

    private void ParserMap_MapStates_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting %% after \"%map mapname\".", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_MapStatesError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_MapStates_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_States_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_MapStates_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting %% after \"%map mapname\".", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StateStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.MapStates State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.MapStatesError State Transitions.
    //

    private void ParserMap_MapStatesError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_MapStatesError_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_States_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_MapStatesError_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addMap();
        }
        finally
        {
            setState(_States[ParserMap_MapName_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_MapStatesError_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createState(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StateStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.MapStatesError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.States State Transitions.
    //

    private void ParserMap_States_Default()
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[stateId]);
        }


        return;
    }


    private void ParserMap_States_ENTRY(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_EntryStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_States_EOD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addMap();
        }
        finally
        {
            setState(_States[ParserMap_MapStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_States_EQUAL(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Transitions_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_States_EXIT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_ExitStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_States_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
            ctxt.createState(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_Transitions_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_States_MAP_NAME(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting \"%%\" before another \"%map\".", token.getLineNumber());
            ctxt.addMap();
        }
        finally
        {
            setState(_States[ParserMap_MapName_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_States_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDuplicateState(token.getValue()))
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Duplicate state name.", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_StateStart_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_StateStart_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    //
    // end of ParserMap.States State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StateStart State Transitions.
    //

    private void ParserMap_StateStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("After the state name is given, then either an entry action, exit action or opening brace is expected.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StateStartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StateStart_ENTRY(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDefaultState())
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Default state may not have an entry action.", token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_EntryStart_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
            }
            finally
            {
                setState(_States[ParserMap_EntryStart_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    private void ParserMap_StateStart_EXIT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.isDefaultState())
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Default state may not have an exit action.", token.getLineNumber());
            }
            finally
            {
                setState(_States[ParserMap_ExitStart_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
            }
            finally
            {
                setState(_States[ParserMap_ExitStart_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    private void ParserMap_StateStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_Transitions_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.StateStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.StateStartError State Transitions.
    //

    private void ParserMap_StateStartError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_StateStartError_ENTRY(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_EntryStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StateStartError_EXIT(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ExitStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_StateStartError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_Transitions_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.StateStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EntryStart State Transitions.
    //

    private void ParserMap_EntryStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("An opening brace is expected after Entry.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StateStartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_EntryStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_EntryEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.EntryStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EntryEnd State Transitions.
    //

    private void ParserMap_EntryEnd_actionsDone(List<SmcAction> actions, int lineNumber)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setEntryAction(actions);
        }
        finally
        {
            setState(_States[ParserMap_StateStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_EntryEnd_actionsError()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_StartState_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.EntryEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ExitStart State Transitions.
    //

    private void ParserMap_ExitStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("A opening brace is expected after Exit.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_StateStartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_ExitStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ExitEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.ExitStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ExitEnd State Transitions.
    //

    private void ParserMap_ExitEnd_actionsDone(List<SmcAction> actions, int lineNumber)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setExitAction(actions);
        }
        finally
        {
            setState(_States[ParserMap_StateStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_ExitEnd_actionsError()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_StateStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.ExitEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.Transitions State Transitions.
    //

    private void ParserMap_Transitions_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a new transition or a closing brace.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_TransError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Transitions_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addState();
        }
        finally
        {
            setState(_States[ParserMap_States_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_Transitions_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.storeTransitionName(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_TransStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.Transitions State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransError State Transitions.
    //

    private void ParserMap_TransError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_TransError_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addState();
        }
        finally
        {
            setState(_States[ParserMap_States_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransError_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.storeTransitionName(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_TransStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.TransError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransStart State Transitions.
    //

    private void ParserMap_TransStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
            ctxt.createTransition(ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_TransStartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStart_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
        }
        finally
        {
            setState(_States[ParserMap_JumpStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStart_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createTransition(token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_TransGuard_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_TransParams_STATE_ID]);
            enterState();
            pushState(_States[ParamMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStart_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);
        }
        finally
        {
            setState(_States[ParserMap_PopStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStart_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_PushStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStart_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createTransition(token.getLineNumber());
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_SimpleTrans_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.TransStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransStartError State Transitions.
    //

    private void ParserMap_TransStartError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_TransStartError_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_JumpStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStartError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("End state missing");
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStartError_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_TransGuard_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStartError_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_TransParams_STATE_ID]);
            enterState();
            pushState(_States[ParamMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStartError_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);
        }
        finally
        {
            setState(_States[ParserMap_PopStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStartError_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_PushStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransStartError_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addGuard();
            ctxt.addTransition();
        }
        finally
        {
            setState(_States[ParserMap_Transitions_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.TransStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransParams State Transitions.
    //

    private void ParserMap_TransParams_paramsDone(List<SmcParameter> params, int lineNumber)
    {
        final int stateId = mState.getId();

        if (ctxt.getTransitionName().equalsIgnoreCase("Default") &&
       !params.isEmpty())
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Default transitions may not have parameters.", lineNumber);
                ctxt.createTransition(params, lineNumber);
            }
            finally
            {
                setState(_States[ParserMap_TransNext_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.createTransition(params, lineNumber);
            }
            finally
            {
                setState(_States[ParserMap_TransNext_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    private void ParserMap_TransParams_paramsError(List<SmcParameter> params, int lineNumber)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createTransition(params, lineNumber);
        }
        finally
        {
            setState(_States[ParserMap_TransNext_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.TransParams State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransNext State Transitions.
    //

    private void ParserMap_TransNext_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_TransNextError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNext_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_JumpStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNext_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_TransGuard_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNext_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);
        }
        finally
        {
            setState(_States[ParserMap_PopStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNext_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_PushStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNext_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_SimpleTrans_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.TransNext State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransNextError State Transitions.
    //

    private void ParserMap_TransNextError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_TransNextError_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_JumpStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNextError_LEFT_BRACKET(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_TransGuard_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNextError_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_TransNextError_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_POP);
        }
        finally
        {
            setState(_States[ParserMap_PopStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNextError_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_PushStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_TransNextError_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_SimpleTrans_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.TransNextError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransGuard State Entry/Exit Actions.
    //

    private void ParserMap_TransGuard__Entry_()
    {
        ctxt.setRawMode("[", "]");
    }

    private void ParserMap_TransGuard__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.TransGuard State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.TransGuard State Transitions.
    //

    private void ParserMap_TransGuard_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createGuard(ctxt.getTransitionName(), token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_EndState_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.TransGuard State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EndState State Transitions.
    //

    private void ParserMap_EndState_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_EndStateError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_EndState_JUMP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_JumpStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_EndState_POP(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setTransType(TransType.TRANS_POP);
        }
        finally
        {
            setState(_States[ParserMap_PopStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_EndState_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setTransType(TransType.TRANS_PUSH);
            ctxt.setEndState("nil");
        }
        finally
        {
            setState(_States[ParserMap_PushStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_EndState_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setTransType(TransType.TRANS_SET);
            ctxt.setEndState(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_SimpleTrans_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.EndState State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.EndStateError State Transitions.
    //

    private void ParserMap_EndStateError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_EndStateError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.EndStateError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.SimpleTrans State Transitions.
    //

    private void ParserMap_SimpleTrans_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_ActionStartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_SimpleTrans_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_SimpleTrans_SLASH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setTransType(TransType.TRANS_PUSH);
        }
        finally
        {
            setState(_States[ParserMap_PushTransition_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.SimpleTrans State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushTransition State Transitions.
    //

    private void ParserMap_PushTransition_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("\"push\" must follow a '/'.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_PushError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PushTransition_PUSH(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_PushStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PushTransition State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushStart State Transitions.
    //

    private void ParserMap_PushStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("\"push\" must be followed by a '/'.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_PushError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PushStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_PushMap_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PushStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushError State Transitions.
    //

    private void ParserMap_PushError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_PushError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PushError_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PushError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushMap State Transitions.
    //

    private void ParserMap_PushMap_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting a state name.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_PushError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PushMap_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setPushState(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_PushEnd_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PushMap State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PushEnd State Transitions.
    //

    private void ParserMap_PushEnd_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("push transition missing closing paren.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_PushError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PushEnd_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PushEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpStart State Transitions.
    //

    private void ParserMap_JumpStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("\"jump\" must be followed by a '/'.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_JumpError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_JumpStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_JumpMap_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.JumpStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpError State Transitions.
    //

    private void ParserMap_JumpError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_JumpError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_JumpError_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.JumpError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpMap State Transitions.
    //

    private void ParserMap_JumpMap_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting a state name.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_JumpError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_JumpMap_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setEndState(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_JumpEnd_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.JumpMap State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.JumpEnd State Transitions.
    //

    private void ParserMap_JumpEnd_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("jump transition missing closing paren.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_JumpError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_JumpEnd_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.JumpEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopStart State Transitions.
    //

    private void ParserMap_PopStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting '(trans)' or opening brace after pop.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_PopError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PopStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PopStart_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_PopAction_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PopStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopError State Transitions.
    //

    private void ParserMap_PopError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_PopError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PopError_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PopError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopAction State Transitions.
    //

    private void ParserMap_PopAction_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting either a pop transition or closing paren.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_PopError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PopAction_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PopAction_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setEndState(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_PopArgs_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PopAction State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopArgs State Transitions.
    //

    private void ParserMap_PopArgs_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_PopArgsEnd_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PopArgs_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Pop transition missing closing paren.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_PopError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_PopArgs_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PopArgs State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopArgsEnd State Entry/Exit Actions.
    //

    private void ParserMap_PopArgsEnd__Entry_()
    {
        ctxt.setRawMode("(", ")");
    }

    private void ParserMap_PopArgsEnd__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParserMap.PopArgsEnd State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.PopArgsEnd State Transitions.
    //

    private void ParserMap_PopArgsEnd_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setPopArgs(token.getValue());
        }
        finally
        {
            setState(_States[ParserMap_ActionStart_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.PopArgsEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ActionStart State Transitions.
    //

    private void ParserMap_ActionStart_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParserMap_ActionStartError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_ActionStart_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.ActionStart State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ActionEnd State Transitions.
    //

    private void ParserMap_ActionEnd_actionsDone(List<SmcAction> actions, int lineNumber)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setActions(actions);
            ctxt.addGuard();
            ctxt.addTransition();
        }
        finally
        {
            setState(_States[ParserMap_Transitions_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParserMap_ActionEnd_actionsError()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParserMap_Transitions_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.ActionEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParserMap.ActionStartError State Transitions.
    //

    private void ParserMap_ActionStartError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ParserMap_ActionStartError_LEFT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createActionList();
        }
        finally
        {
            setState(_States[ParserMap_ActionEnd_STATE_ID]);
            enterState();
            pushState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParserMap.ActionStartError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Start State Entry/Exit Actions.
    //

    private void ParamMap_Start__Entry_()
    {
        ctxt.createParamList();
    }

    //
    // end of ParamMap.Start State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Start State Transitions.
    //

    private void ParamMap_Start_DOLLAR(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
        {
            exitState();

            try
            {
                // No actions.
            }
            finally
            {
                setState(_States[ParamMap_Dollar_STATE_ID]);
            }

            enterState();
        }
        else
        {
            ParamMap_Start_Default();
        }


        return;
    }


    private void ParamMap_Start_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParamMap_Error_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParamMap_Start_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            popState();
        }


        paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());

        return;
    }


    private void ParamMap_Start_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createParameter(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParamMap_ParamSeparator_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParamMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Dollar State Transitions.
    //

    private void ParamMap_Dollar_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParamMap_Error_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParamMap_Dollar_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createParameter("$" + token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ParamMap_ParamSeparator_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParamMap.Dollar State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.ParamSeparator State Transitions.
    //

    private void ParamMap_ParamSeparator_COLON(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ParamMap_ParamType_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParamMap_ParamSeparator_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.JS ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
        {
            exitState();

            try
            {
                clearState();
                ctxt.addParameter();
            }
            finally
            {
                setState(_States[ParamMap_Start_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Parameter type missing.", token.getLineNumber());
            }
            finally
            {
                setState(_States[ParamMap_Error_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    private void ParamMap_ParamSeparator_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParamMap_Error_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParamMap_ParamSeparator_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.JS ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
        {
            exitState();

            try
            {
                clearState();
                ctxt.addParameter();
            }
            finally
            {
                popState();
            }


            paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.error("Parameter type missing.", token.getLineNumber());
            }
            finally
            {
                popState();
            }


            paramsError(
            ctxt.getParamList(),
            token.getLineNumber());
        }

        return;
    }


    //
    // end of ParamMap.ParamSeparator State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.ParamType State Entry/Exit Actions.
    //

    private void ParamMap_ParamType__Entry_()
    {
        ctxt.setRawMode2();
    }

    private void ParamMap_ParamType__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParamMap.ParamType State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.ParamType State Transitions.
    //

    private void ParamMap_ParamType_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setParamType(token.getValue());
        }
        finally
        {
            setState(_States[ParamMap_NextParam_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ParamMap.ParamType State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.NextParam State Transitions.
    //

    private void ParamMap_NextParam_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addParameter();
        }
        finally
        {
            setState(_States[ParamMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParamMap_NextParam_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ParamMap_Error_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ParamMap_NextParam_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addParameter();
        }
        finally
        {
            popState();
        }


        paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());

        return;
    }


    //
    // end of ParamMap.NextParam State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Error State Entry/Exit Actions.
    //

    private void ParamMap_Error__Entry_()
    {
        ctxt.setRawMode("(", ")");
        ctxt.clearParameter();
    }

    private void ParamMap_Error__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ParamMap.Error State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ParamMap.Error State Transitions.
    //

    private void ParamMap_Error_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            popState();
        }


        paramsError(
            ctxt.getParamList(),
            token.getLineNumber());

        return;
    }


    //
    // end of ParamMap.Error State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.Start State Transitions.
    //

    private void ActionMap_Start_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.clearActions();
            ctxt.error("Expecting either a method name or a closing brace", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ActionMap_ActionError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ActionMap_Start_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            popState();
        }


        actionsDone(
            ctxt.getActionList(),
            token.getLineNumber());

        return;
    }


    private void ActionMap_Start_WORD(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createAction(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ActionMap_ActionName_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ActionMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionName State Transitions.
    //

    private void ActionMap_ActionName_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.clearActions();
            ctxt.error("Expecting an open paren after the method name", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ActionMap_ActionError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ActionMap_ActionName_EQUAL(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        if (ctxt.getTargetLanguage() != TargetLanguage.GRAPH &&
       ctxt.getTargetLanguage() != TargetLanguage.C_SHARP &&
       ctxt.getTargetLanguage() != TargetLanguage.GROOVY &&
       ctxt.getTargetLanguage() != TargetLanguage.JS &&
       ctxt.getTargetLanguage() != TargetLanguage.LUA &&
       ctxt.getTargetLanguage() != TargetLanguage.PERL &&
       ctxt.getTargetLanguage() != TargetLanguage.PYTHON &&
       ctxt.getTargetLanguage() != TargetLanguage.RUBY &&
       ctxt.getTargetLanguage() != TargetLanguage.SCALA &&
       ctxt.getTargetLanguage() != TargetLanguage.VB &&
       ctxt.getTargetLanguage() != TargetLanguage.TABLE)
        {
            exitState();

            try
            {
                clearState();
                ctxt.clearActions();
                ctxt.error("'=' property assignment may only be used with -vb, -csharp or -graph", token.getLineNumber());
            }
            finally
            {
                setState(_States[ActionMap_ActionError_STATE_ID]);
            }

            enterState();
        }
        else
        {
            exitState();

            try
            {
                clearState();
                ctxt.setProperty(true);
                ctxt.createArgList();
            }
            finally
            {
                setState(_States[ActionMap_PropertyAssignment_STATE_ID]);
            }

            enterState();
        }

        return;
    }


    private void ActionMap_ActionName_LEFT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        try
        {
            clearState();
            ctxt.createArgList();
        }
        finally
        {
            setState(_States[ActionMap_ActionArgs_STATE_ID]);
            enterState();
            pushState(_States[ArgsMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ActionMap.ActionName State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionArgs State Transitions.
    //

    private void ActionMap_ActionArgs_argsDone(List<String> args)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.setActionArgs(args);
        }
        finally
        {
            setState(_States[ActionMap_ActionEnd_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ActionMap_ActionArgs_argsError()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            setState(_States[ActionMap_ActionError_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ActionMap.ActionArgs State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionEnd State Transitions.
    //

    private void ActionMap_ActionEnd_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Expecting a ';' after closing paren", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ActionMap_ActionError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ActionMap_ActionEnd_SEMICOLON(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addAction();
        }
        finally
        {
            setState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ActionMap.ActionEnd State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.PropertyAssignment State Entry/Exit Actions.
    //

    private void ActionMap_PropertyAssignment__Entry_()
    {
        ctxt.setRawMode(";");
    }

    private void ActionMap_PropertyAssignment__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ActionMap.PropertyAssignment State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.PropertyAssignment State Transitions.
    //

    private void ActionMap_PropertyAssignment_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing ';' at end of property assignment", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ActionMap_ActionError_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ActionMap_PropertyAssignment_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createArgument(token.getValue(), token.getLineNumber());
            ctxt.addArgument();
            ctxt.setActionArgs(ctxt.getArgsList());
            ctxt.addAction();
        }
        finally
        {
            setState(_States[ActionMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ActionMap.PropertyAssignment State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ActionMap.ActionError State Transitions.
    //

    private void ActionMap_ActionError_Default()
    {
        final int stateId = mState.getId();

        try
        {
        }
        finally
        {
        }


        return;
    }


    private void ActionMap_ActionError_RIGHT_BRACE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            popState();
        }


        actionsError();

        return;
    }


    //
    // end of ActionMap.ActionError State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Start State Entry/Exit Actions.
    //

    private void ArgsMap_Start__Entry_()
    {
        ctxt.setRawMode2();
    }

    private void ArgsMap_Start__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ArgsMap.Start State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Start State Transitions.
    //

    private void ArgsMap_Start_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.createArgument(token.getValue(), token.getLineNumber());
        }
        finally
        {
            setState(_States[ArgsMap_NextArg_STATE_ID]);
        }

        enterState();

        return;
    }


    //
    // end of ArgsMap.Start State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.NextArg State Transitions.
    //

    private void ArgsMap_NextArg_COMMA(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addArgument();
        }
        finally
        {
            setState(_States[ArgsMap_Start_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ArgsMap_NextArg_Default()
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.error("Missing ',' or closing paren after argument.", ctxt.getLineNumber());
        }
        finally
        {
            setState(_States[ArgsMap_Error_STATE_ID]);
        }

        enterState();

        return;
    }


    private void ArgsMap_NextArg_RIGHT_PAREN(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
            clearState();
            ctxt.addArgument();
        }
        finally
        {
            popState();
        }


        argsDone( ctxt.getArgsList());

        return;
    }


    //
    // end of ArgsMap.NextArg State Transitions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Error State Entry/Exit Actions.
    //

    private void ArgsMap_Error__Entry_()
    {
        ctxt.setRawMode("{", "}");
        ctxt.clearArguments();
    }

    private void ArgsMap_Error__Exit_()
    {
        ctxt.setCookedMode();
    }

    //
    // end of ArgsMap.Error State Entry/Exit Actions.
    //-----------------------------------------------------------

    //-----------------------------------------------------------
    // ArgsMap.Error State Transitions.
    //

    private void ArgsMap_Error_SOURCE(SmcLexer.Token token)
    {
        final int stateId = mState.getId();

        exitState();

        try
        {
        }
        finally
        {
            popState();
        }


        argsError();

        return;
    }


    //
    // end of ArgsMap.Error State Transitions.
    //-----------------------------------------------------------

//---------------------------------------------------------------
// Member data.
//

    transient private SmcParser ctxt;

    //-----------------------------------------------------------
    // Constants.
    //

    private static final long serialVersionUID = 1L;

    public static final int ParserMap_Start_STATE_ID = 0;
    public static final int ParserMap_Context_STATE_ID = 1;
    public static final int ParserMap_StartState_STATE_ID = 2;
    public static final int ParserMap_HeaderFile_STATE_ID = 3;
    public static final int ParserMap_IncludeFile_STATE_ID = 4;
    public static final int ParserMap_Package_STATE_ID = 5;
    public static final int ParserMap_FsmClassName_STATE_ID = 6;
    public static final int ParserMap_FsmFileName_STATE_ID = 7;
    public static final int ParserMap_Import_STATE_ID = 8;
    public static final int ParserMap_Declare_STATE_ID = 9;
    public static final int ParserMap_Access_STATE_ID = 10;
    public static final int ParserMap_StartError_STATE_ID = 11;
    public static final int ParserMap_MapStart_STATE_ID = 12;
    public static final int ParserMap_MapStartError_STATE_ID = 13;
    public static final int ParserMap_MapName_STATE_ID = 14;
    public static final int ParserMap_MapStates_STATE_ID = 15;
    public static final int ParserMap_MapStatesError_STATE_ID = 16;
    public static final int ParserMap_States_STATE_ID = 17;
    public static final int ParserMap_StateStart_STATE_ID = 18;
    public static final int ParserMap_StateStartError_STATE_ID = 19;
    public static final int ParserMap_EntryStart_STATE_ID = 20;
    public static final int ParserMap_EntryEnd_STATE_ID = 21;
    public static final int ParserMap_ExitStart_STATE_ID = 22;
    public static final int ParserMap_ExitEnd_STATE_ID = 23;
    public static final int ParserMap_Transitions_STATE_ID = 24;
    public static final int ParserMap_TransError_STATE_ID = 25;
    public static final int ParserMap_TransStart_STATE_ID = 26;
    public static final int ParserMap_TransStartError_STATE_ID = 27;
    public static final int ParserMap_TransParams_STATE_ID = 28;
    public static final int ParserMap_TransNext_STATE_ID = 29;
    public static final int ParserMap_TransNextError_STATE_ID = 30;
    public static final int ParserMap_TransGuard_STATE_ID = 31;
    public static final int ParserMap_EndState_STATE_ID = 32;
    public static final int ParserMap_EndStateError_STATE_ID = 33;
    public static final int ParserMap_SimpleTrans_STATE_ID = 34;
    public static final int ParserMap_PushTransition_STATE_ID = 35;
    public static final int ParserMap_PushStart_STATE_ID = 36;
    public static final int ParserMap_PushError_STATE_ID = 37;
    public static final int ParserMap_PushMap_STATE_ID = 38;
    public static final int ParserMap_PushEnd_STATE_ID = 39;
    public static final int ParserMap_JumpStart_STATE_ID = 40;
    public static final int ParserMap_JumpError_STATE_ID = 41;
    public static final int ParserMap_JumpMap_STATE_ID = 42;
    public static final int ParserMap_JumpEnd_STATE_ID = 43;
    public static final int ParserMap_PopStart_STATE_ID = 44;
    public static final int ParserMap_PopError_STATE_ID = 45;
    public static final int ParserMap_PopAction_STATE_ID = 46;
    public static final int ParserMap_PopArgs_STATE_ID = 47;
    public static final int ParserMap_PopArgsEnd_STATE_ID = 48;
    public static final int ParserMap_ActionStart_STATE_ID = 49;
    public static final int ParserMap_ActionEnd_STATE_ID = 50;
    public static final int ParserMap_ActionStartError_STATE_ID = 51;

    public static final int ParamMap_Start_STATE_ID = 52;
    public static final int ParamMap_Dollar_STATE_ID = 53;
    public static final int ParamMap_ParamSeparator_STATE_ID = 54;
    public static final int ParamMap_ParamType_STATE_ID = 55;
    public static final int ParamMap_NextParam_STATE_ID = 56;
    public static final int ParamMap_Error_STATE_ID = 57;

    public static final int ActionMap_Start_STATE_ID = 58;
    public static final int ActionMap_ActionName_STATE_ID = 59;
    public static final int ActionMap_ActionArgs_STATE_ID = 60;
    public static final int ActionMap_ActionEnd_STATE_ID = 61;
    public static final int ActionMap_PropertyAssignment_STATE_ID = 62;
    public static final int ActionMap_ActionError_STATE_ID = 63;

    public static final int ArgsMap_Start_STATE_ID = 64;
    public static final int ArgsMap_NextArg_STATE_ID = 65;
    public static final int ArgsMap_Error_STATE_ID = 66;

    private static final int STATE_COUNT = 67;

    private static final int ACCESS42_TRANSITION_ID = 1;
    private static final int CLASS_NAME35_TRANSITION_ID = 2;
    private static final int COLON175_TRANSITION_ID = 3;
    private static final int COMMA199_TRANSITION_ID = 4;
    private static final int DECLARE41_TRANSITION_ID = 5;
    private static final int DOLLAR171_TRANSITION_ID = 6;
    private static final int ENTRY71_TRANSITION_ID = 7;
    private static final int EOD59_TRANSITION_ID = 8;
    private static final int EQUAL188_TRANSITION_ID = 9;
    private static final int EXIT72_TRANSITION_ID = 10;
    private static final int FSM_CLASS_NAME36_TRANSITION_ID = 11;
    private static final int FSM_FILE_NAME37_TRANSITION_ID = 12;
    private static final int HEADER_FILE38_TRANSITION_ID = 13;
    private static final int IMPORT40_TRANSITION_ID = 14;
    private static final int INCLUDE_FILE7_TRANSITION_ID = 15;
    private static final int JUMP122_TRANSITION_ID = 16;
    private static final int LEFT_BRACE167_TRANSITION_ID = 17;
    private static final int LEFT_BRACKET113_TRANSITION_ID = 18;
    private static final int LEFT_PAREN187_TRANSITION_ID = 19;
    private static final int MAP_NAME65_TRANSITION_ID = 20;
    private static final int PACKAGE_NAME39_TRANSITION_ID = 21;
    private static final int POP121_TRANSITION_ID = 22;
    private static final int PUSH130_TRANSITION_ID = 23;
    private static final int RIGHT_BRACE196_TRANSITION_ID = 24;
    private static final int RIGHT_PAREN200_TRANSITION_ID = 25;
    private static final int SEMICOLON192_TRANSITION_ID = 26;
    private static final int SLASH127_TRANSITION_ID = 27;
    private static final int SOURCE202_TRANSITION_ID = 28;
    private static final int START_STATE34_TRANSITION_ID = 29;
    private static final int WORD184_TRANSITION_ID = 30;
    private static final int actionsDone165_TRANSITION_ID = 31;
    private static final int actionsError166_TRANSITION_ID = 32;
    private static final int argsDone190_TRANSITION_ID = 33;
    private static final int argsError191_TRANSITION_ID = 34;
    private static final int paramsDone104_TRANSITION_ID = 35;
    private static final int paramsError105_TRANSITION_ID = 36;

    private static final int TRANSITION_COUNT = 37;

    private static final MethodType[] TRANSITION_TYPES =
    {
        NO_ARGS_TYPE,
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, SmcLexer.Token.class),
        MethodType.methodType(void.class, List.class, int.class),
        NO_ARGS_TYPE,
        MethodType.methodType(void.class, List.class),
        NO_ARGS_TYPE,
        MethodType.methodType(void.class, List.class, int.class),
        MethodType.methodType(void.class, List.class, int.class)
    };

    private static final String[] MAP_NAMES =
    {
        "ParserMap",
        "ParamMap",
        "ActionMap",
        "ArgsMap"
    };

    private static final String[][] STATE_NAMES =
    {
        new String[]
        {
            "Start",
            "Context",
            "StartState",
            "HeaderFile",
            "IncludeFile",
            "Package",
            "FsmClassName",
            "FsmFileName",
            "Import",
            "Declare",
            "Access",
            "StartError",
            "MapStart",
            "MapStartError",
            "MapName",
            "MapStates",
            "MapStatesError",
            "States",
            "StateStart",
            "StateStartError",
            "EntryStart",
            "EntryEnd",
            "ExitStart",
            "ExitEnd",
            "Transitions",
            "TransError",
            "TransStart",
            "TransStartError",
            "TransParams",
            "TransNext",
            "TransNextError",
            "TransGuard",
            "EndState",
            "EndStateError",
            "SimpleTrans",
            "PushTransition",
            "PushStart",
            "PushError",
            "PushMap",
            "PushEnd",
            "JumpStart",
            "JumpError",
            "JumpMap",
            "JumpEnd",
            "PopStart",
            "PopError",
            "PopAction",
            "PopArgs",
            "PopArgsEnd",
            "ActionStart",
            "ActionEnd",
            "ActionStartError"
        },

        new String[]
        {
            "Start",
            "Dollar",
            "ParamSeparator",
            "ParamType",
            "NextParam",
            "Error"
        },

        new String[]
        {
            "Start",
            "ActionName",
            "ActionArgs",
            "ActionEnd",
            "PropertyAssignment",
            "ActionError"
        },

        new String[]
        {
            "Start",
            "NextArg",
            "Error"
        }
    };

    private static String[][] STATE_TRANSITIONS =
    {
        new String[]
        {
            "ACCESS",
            "CLASS_NAME",
            "DECLARE",
            "Default",
            "FSM_CLASS_NAME",
            "FSM_FILE_NAME",
            "HEADER_FILE",
            "IMPORT",
            "INCLUDE_FILE",
            "MAP_NAME",
            "PACKAGE_NAME",
            "SOURCE",
            "START_STATE"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "ACCESS",
            "CLASS_NAME",
            "DECLARE",
            "Default",
            "FSM_CLASS_NAME",
            "FSM_FILE_NAME",
            "HEADER_FILE",
            "IMPORT",
            "MAP_NAME",
            "PACKAGE_NAME",
            "START_STATE"
        },

        new String[]
        {
            "Default",
            "MAP_NAME"
        },

        new String[]
        {
            "Default",
            "MAP_NAME"
        },

        new String[]
        {
            "Default",
            "EOD",
            "WORD"
        },

        new String[]
        {
            "Default",
            "EOD",
            "WORD"
        },

        new String[]
        {
            "Default",
            "EOD",
            "MAP_NAME",
            "WORD"
        },

        new String[]
        {
            "Default",
            "ENTRY",
            "EOD",
            "EQUAL",
            "EXIT",
            "LEFT_BRACE",
            "MAP_NAME",
            "WORD"
        },

        new String[]
        {
            "Default",
            "ENTRY",
            "EXIT",
            "LEFT_BRACE"
        },

        new String[]
        {
            "Default",
            "ENTRY",
            "EXIT",
            "LEFT_BRACE"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "actionsDone",
            "actionsError"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "actionsDone",
            "actionsError"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE",
            "WORD"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE",
            "WORD"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACKET",
            "LEFT_PAREN",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACE",
            "LEFT_BRACKET",
            "LEFT_PAREN",
            "POP",
            "PUSH",
            "RIGHT_BRACE"
        },

        new String[]
        {
            "paramsDone",
            "paramsError"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACKET",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "LEFT_BRACKET",
            "LEFT_PAREN",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "JUMP",
            "POP",
            "PUSH",
            "WORD"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "SLASH"
        },

        new String[]
        {
            "Default",
            "PUSH"
        },

        new String[]
        {
            "Default",
            "LEFT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "LEFT_PAREN"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "Default",
            "RIGHT_PAREN",
            "WORD"
        },

        new String[]
        {
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "actionsDone",
            "actionsError"
        },

        new String[]
        {
            "Default",
            "LEFT_BRACE"
        },

        new String[]
        {
            "DOLLAR",
            "Default",
            "RIGHT_PAREN",
            "WORD"
        },

        new String[]
        {
            "Default",
            "WORD"
        },

        new String[]
        {
            "COLON",
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE",
            "WORD"
        },

        new String[]
        {
            "Default",
            "EQUAL",
            "LEFT_PAREN"
        },

        new String[]
        {
            "argsDone",
            "argsError"
        },

        new String[]
        {
            "Default",
            "SEMICOLON"
        },

        new String[]
        {
            "Default",
            "SOURCE"
        },

        new String[]
        {
            "Default",
            "RIGHT_BRACE"
        },

        new String[]
        {
            "SOURCE"
        },

        new String[]
        {
            "COMMA",
            "Default",
            "RIGHT_PAREN"
        },

        new String[]
        {
            "SOURCE"
        }
    };

    private static final String[] TRANSITION_NAMES =
    {
        "Default",
        "ACCESS",
        "CLASS_NAME",
        "COLON",
        "COMMA",
        "DECLARE",
        "DOLLAR",
        "ENTRY",
        "EOD",
        "EQUAL",
        "EXIT",
        "FSM_CLASS_NAME",
        "FSM_FILE_NAME",
        "HEADER_FILE",
        "IMPORT",
        "INCLUDE_FILE",
        "JUMP",
        "LEFT_BRACE",
        "LEFT_BRACKET",
        "LEFT_PAREN",
        "MAP_NAME",
        "PACKAGE_NAME",
        "POP",
        "PUSH",
        "RIGHT_BRACE",
        "RIGHT_PAREN",
        "SEMICOLON",
        "SLASH",
        "SOURCE",
        "START_STATE",
        "WORD",
        "actionsDone",
        "actionsError",
        "argsDone",
        "argsError",
        "paramsDone",
        "paramsError"
    };

    private static final State7[] _States = new State7[STATE_COUNT];

    static
    {
        final Lookup lookup = MethodHandles.lookup();
        final Class<?> clazz = SmcParserContext.class;
        final int mapSize = MAP_NAMES.length;
        int stateSize;
        int mapIndex;
        int stateIndex;
        int transIndex;
        int stateId = 0;
        String mapName;
        String stateName;
        String transName;
        String methodName;
        MethodType transType;
        MethodHandle entryHandle;
        MethodHandle exitHandle;
        TransitionHandle[] transitions;

        for (mapIndex = 0; mapIndex < mapSize; ++mapIndex)
        {
            mapName = MAP_NAMES[mapIndex];
            stateSize = STATE_NAMES[mapIndex].length;

            for (stateIndex = 0; stateIndex < stateSize; ++stateIndex, ++stateId)
            {
                stateName = STATE_NAMES[mapIndex][stateIndex];
                transitions = new TransitionHandle[TRANSITION_COUNT];

                methodName = String.format(ENTRY_NAME, mapName, stateName);
                entryHandle = lookupMethod(lookup, clazz, methodName, NO_ARGS_TYPE);
                methodName = String.format(EXIT_NAME, mapName, stateName);
                exitHandle = lookupMethod(lookup, clazz, methodName, NO_ARGS_TYPE);

                for (transIndex = 1; transIndex < TRANSITION_COUNT; ++transIndex)
                {
                    transName = TRANSITION_NAMES[transIndex];
                    transType = TRANSITION_TYPES[transIndex];
                    transitions[transIndex] =
                        lookupTransition(lookup, clazz, mapName, stateName, transName, transType);
                }

                _States[stateId] =
                    new State7(
                        String.format(STATE_NAME_FORMAT, mapName, stateName),
                        stateId,
                        entryHandle,
                        exitHandle,
                        transitions,
                        STATE_TRANSITIONS[stateId]);

            }
        }
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
